"""
Vulnerability Scanner Module
Scans smart contracts for known vulnerabilities using ML and static analysis
"""

import json
from typing import Dict, Any, List
from smartsploit.core.framework import BaseAuxiliary, Target, ExploitResult, ExploitInfo

class VulnerabilityScanner(BaseAuxiliary):
    """
    Vulnerability Scanner
    Performs comprehensive vulnerability scanning of smart contracts
    """
    
    def __init__(self):
        super().__init__()
        
        # Module information
        self.info = ExploitInfo(
            name="Smart Contract Vulnerability Scanner",
            description="Comprehensive vulnerability scanning using ML and static analysis",
            author="SmartSploit Research Team",
            references=[
                "OWASP Smart Contract Security",
                "SWC Registry",
                "ConsenSys Best Practices"
            ],
            severity="info",
            targets=["any smart contract"],
            reliability=0.90
        )
        
        # Required options
        self.required_options = ["TARGET"]
        
        # Module options
        self.options = {
            "TARGET": None,              # Target contract address
            "NETWORK": "mainnet",        # Blockchain network
            "DEEP_SCAN": True,          # Enable deep analysis
            "ML_DETECTION": True,       # Use ML vulnerability detection
            "STATIC_ANALYSIS": True,    # Use static analysis
            "OUTPUT_FORMAT": "json",    # Output format (json, text)
            "SAVE_RESULTS": False       # Save results to file
        }
        
    def run(self, **kwargs) -> Dict[str, Any]:
        """Main scanning execution"""
        if not self.validate_options():
            return {"result": ExploitResult.ERROR, "message": "Invalid options"}
            
        target_addr = self.get_option("TARGET")
        if not target_addr:
            return {"result": ExploitResult.ERROR, "message": "No target specified"}
            
        print(f"[*] Starting vulnerability scan for {target_addr}")
        
        try:
            # Create target object
            target = Target(
                address=target_addr,
                network=self.get_option("NETWORK")
            )
            
            # Perform comprehensive scan
            results = self.scan(target_addr)
            
            return {
                "result": ExploitResult.SUCCESS,
                "message": "Vulnerability scan completed",
                "data": results
            }
            
        except Exception as e:
            return {
                "result": ExploitResult.ERROR,
                "message": f"Scan error: {str(e)}"
            }
    
    def scan(self, target: str) -> Dict[str, Any]:
        """Perform comprehensive vulnerability scan"""
        print(f"[+] Scanning contract: {target}")
        
        results = {
            "contract_address": target,
            "network": self.get_option("NETWORK"),
            "scan_timestamp": "2025-08-08T12:00:00Z",
            "vulnerabilities": {},
            "risk_score": 0.0,
            "risk_level": "LOW",
            "recommendations": [],
            "analysis_methods": []
        }
        
        # Basic contract info
        print("[*] Gathering contract information...")
        results["contract_info"] = self._get_contract_info(target)
        
        # Static analysis
        if self.get_option("STATIC_ANALYSIS"):
            print("[*] Performing static analysis...")
            static_results = self._static_analysis(target)
            results["vulnerabilities"].update(static_results["vulnerabilities"])
            results["analysis_methods"].append("static_analysis")
        
        # ML-based detection
        if self.get_option("ML_DETECTION"):
            print("[*] Running ML vulnerability detection...")
            ml_results = self._ml_detection(target)
            results["vulnerabilities"].update(ml_results["vulnerabilities"])
            results["analysis_methods"].append("ml_detection")
        
        # Deep scan
        if self.get_option("DEEP_SCAN"):
            print("[*] Performing deep vulnerability analysis...")
            deep_results = self._deep_scan(target)
            results["vulnerabilities"].update(deep_results["vulnerabilities"])
            results["analysis_methods"].append("deep_scan")
        
        # Calculate overall risk score
        results["risk_score"], results["risk_level"] = self._calculate_risk_score(results["vulnerabilities"])
        
        # Generate recommendations
        results["recommendations"] = self._generate_recommendations(results["vulnerabilities"])
        
        # Print summary
        self._print_scan_summary(results)
        
        return results
    
    def _get_contract_info(self, address: str) -> Dict[str, Any]:
        """Get basic contract information"""
        # Demo contract info
        return {
            "address": address,
            "balance": "1.234 ETH",
            "code_size": "12,345 bytes",
            "creation_block": "18,234,567",
            "transaction_count": "1,234",
            "is_contract": True,
            "is_verified": False
        }
    
    def _static_analysis(self, address: str) -> Dict[str, Any]:
        """Perform static analysis"""
        vulnerabilities = {}
        
        # Simulate static analysis findings
        vulnerabilities["reentrancy"] = {
            "detected": True,
            "confidence": 0.85,
            "severity": "HIGH",
            "description": "Potential reentrancy vulnerability in withdraw function",
            "locations": ["function withdraw(uint256)", "line 45-52"],
            "method": "static_analysis"
        }
        
        vulnerabilities["integer_overflow"] = {
            "detected": True,
            "confidence": 0.70,
            "severity": "MEDIUM", 
            "description": "Unsafe arithmetic operations detected",
            "locations": ["function transfer(uint256)", "line 28"],
            "method": "static_analysis"
        }
        
        vulnerabilities["unchecked_external_calls"] = {
            "detected": True,
            "confidence": 0.90,
            "severity": "MEDIUM",
            "description": "External call without checking return value",
            "locations": ["function execute()", "line 67"],
            "method": "static_analysis"
        }
        
        return {"vulnerabilities": vulnerabilities}
    
    def _ml_detection(self, address: str) -> Dict[str, Any]:
        """Perform ML-based vulnerability detection"""
        vulnerabilities = {}
        
        # Simulate ML detection results
        ml_scores = {
            "reentrancy": 0.92,
            "access_control": 0.76,
            "timestamp_dependence": 0.45,
            "denial_of_service": 0.33,
            "front_running": 0.68
        }
        
        for vuln_type, score in ml_scores.items():
            if score > 0.5:  # Threshold for detection
                severity = "HIGH" if score > 0.8 else "MEDIUM" if score > 0.6 else "LOW"
                vulnerabilities[vuln_type] = {
                    "detected": True,
                    "confidence": score,
                    "severity": severity,
                    "description": f"ML model detected {vuln_type} vulnerability",
                    "ml_score": score,
                    "method": "ml_detection"
                }
        
        return {"vulnerabilities": vulnerabilities}
    
    def _deep_scan(self, address: str) -> Dict[str, Any]:
        """Perform deep vulnerability scan"""
        vulnerabilities = {}
        
        # Simulate deep scan findings
        vulnerabilities["tx_origin_authentication"] = {
            "detected": True,
            "confidence": 0.88,
            "severity": "MEDIUM",
            "description": "Contract uses tx.origin for authentication",
            "exploit_difficulty": "LOW",
            "method": "deep_scan"
        }
        
        vulnerabilities["weak_randomness"] = {
            "detected": True,
            "confidence": 0.75,
            "severity": "LOW",
            "description": "Weak randomness source detected (block variables)",
            "exploit_difficulty": "MEDIUM",
            "method": "deep_scan"
        }
        
        return {"vulnerabilities": vulnerabilities}
    
    def _calculate_risk_score(self, vulnerabilities: Dict) -> tuple:
        """Calculate overall risk score"""
        total_score = 0.0
        weight_sum = 0.0
        
        severity_weights = {
            "HIGH": 1.0,
            "MEDIUM": 0.6,
            "LOW": 0.3
        }
        
        for vuln_name, vuln_data in vulnerabilities.items():
            if vuln_data.get("detected"):
                confidence = vuln_data.get("confidence", 0.5)
                severity = vuln_data.get("severity", "LOW")
                weight = severity_weights.get(severity, 0.3)
                
                total_score += confidence * weight
                weight_sum += weight
        
        if weight_sum > 0:
            risk_score = total_score / weight_sum
        else:
            risk_score = 0.0
        
        # Classify risk level
        if risk_score >= 0.75:
            risk_level = "HIGH"
        elif risk_score >= 0.45:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        return risk_score, risk_level
    
    def _generate_recommendations(self, vulnerabilities: Dict) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        for vuln_name, vuln_data in vulnerabilities.items():
            if not vuln_data.get("detected"):
                continue
                
            if vuln_name == "reentrancy":
                recommendations.append("Implement checks-effects-interactions pattern")
                recommendations.append("Use OpenZeppelin's ReentrancyGuard modifier")
                
            elif vuln_name == "integer_overflow":
                recommendations.append("Use SafeMath library or Solidity 0.8+ built-in checks")
                
            elif vuln_name == "unchecked_external_calls":
                recommendations.append("Always check return values of external calls")
                recommendations.append("Use require() statements after external calls")
                
            elif vuln_name == "tx_origin_authentication":
                recommendations.append("Replace tx.origin with msg.sender for authentication")
                
            elif vuln_name == "weak_randomness":
                recommendations.append("Use secure randomness source (Chainlink VRF)")
                
            elif vuln_name == "access_control":
                recommendations.append("Implement proper access control mechanisms")
                recommendations.append("Use OpenZeppelin's AccessControl contracts")
        
        # Add general recommendations
        recommendations.extend([
            "Conduct regular security audits",
            "Implement comprehensive unit tests",
            "Use static analysis tools in development",
            "Follow security best practices and guidelines"
        ])
        
        return list(set(recommendations))  # Remove duplicates
    
    def _print_scan_summary(self, results: Dict[str, Any]):
        """Print scan summary"""
        vulnerabilities = results["vulnerabilities"]
        detected_count = sum(1 for v in vulnerabilities.values() if v.get("detected"))
        
        print(f"\n{'='*60}")
        print(f"VULNERABILITY SCAN SUMMARY")
        print(f"{'='*60}")
        print(f"Contract: {results['contract_address']}")
        print(f"Network: {results['network']}")
        print(f"Risk Level: {results['risk_level']}")
        print(f"Risk Score: {results['risk_score']:.2f}")
        print(f"Vulnerabilities Found: {detected_count}")
        
        if detected_count > 0:
            print(f"\nDETECTED VULNERABILITIES:")
            print(f"{'-'*40}")
            
            for vuln_name, vuln_data in vulnerabilities.items():
                if vuln_data.get("detected"):
                    print(f"â€¢ {vuln_name.upper()}")
                    print(f"  Severity: {vuln_data.get('severity', 'UNKNOWN')}")
                    print(f"  Confidence: {vuln_data.get('confidence', 0):.2f}")
                    print(f"  Description: {vuln_data.get('description', 'No description')}")
                    print()
        else:
            print(f"\n[+] No vulnerabilities detected!")
        
        print(f"Analysis Methods: {', '.join(results['analysis_methods'])}")
        print(f"{'='*60}")
